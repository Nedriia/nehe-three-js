<!-- -------------------------------------
  NeHe Tutorial 10
  Original:  http://nehe.gamedev.net/tutorial/loading_and_moving_through_a_3d_world/22003/
  
  @author: rkwright@geofx.com
-------------------------------------- -->
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>Three.js/NEHE Tutorial #10</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

		<!-- The following meta line optimizes the site for mobile devices. It sets the viewport size
		to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
		<link rel="stylesheet" type="text/css" href="NEHE.css" /> 

		<!-- Include two libraries from THREE.js: Core and the Detector for WebGL -->
		<script src="../js/three.js" type="text/javascript"></script>
		<script src="../js/Detector.js" type="text/javascript"></script>
		<script src="../js/OrbitControls.js" type="text/javascript"></script>
		<script src="../js/Stats.js" type="text/javascript"></script>
		<script src="Scene.js" type="text/javascript"></script>
		
		<script id="vertexShader" type="shader">
		// create a shared variable for the VS and FS containing the normal
		varying vec3     vNormal;
		attribute float  displacement;
		uniform float    amplitude;
		
		void main() {
			// set the vNormal value with the attribute value passed in by Three.js
				vNormal = normal;

				// push the displacement into the three slots of a 3D vector so it can
				// be used in operations with other 3D vectors like positions and normals
				vec3 newPosition = position + normal * vec3(displacement * amplitude);

				gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
		}
	</script>
	<script id="fragmentShader" type="shader">
		// create a shared variable for the VS and FS containing the normal
		varying vec3 vNormal;
		precision highp float;

		void main(void) {
			// calculate the dot product and clamp 0 -> 1 rather than -1 -> 1
			  vec3 light = vec3(0.5, 0.2, 1.0);

			  // ensure it's normalized
			  light = normalize(light);

			  // calculate the dot product of the light to the vertex normal
			  float dProd = max(0.0, dot(vNormal, light));

			  // feed into our fragment color
			  gl_FragColor = vec4(dProd, // R
			                      dProd, // G
			                      dProd, // B
			                      1.0);  // A		
		}
	</script>
	</head>
	<body>	
		<!-- This JavaScript block encloses the Three.js commands -->
		<script>
			// allocate the Scene object, request orbitControls and an set of 3D axes 10 units high
			var nScene = new Scene( { axisHeight:10, controls:true, displayStats:true });
			
			var wiggle_count = 0;		// Counter Used To Control How Fast Flag Waves
			var points = [];
			var material;
			var uniforms;
			
			// set up the THREE.js scene via our Scene object
			nScene.initialize();
			
			// then initialize our demo's stuff
			initializeDemo();

			// Animate the scene
			animateScene();

			/**
			 * Initialize the Demo.  This is NeHe #1: http://nehe.gamedev.net/tutorial/flag_effect_%28waving_texture%29/16002/
			 * Create a image mapped texture which is then oscillated (in a sine wave)
			 */
			function initializeDemo() {
				
				/*
				// set up the set of points which will be varied to create the "wave"
				for ( var x=0; x<45; x++ )
				{
					points[x] = [];
					for( var y=0; y<45; y++ )
					{
						points[x][y] = [];
						points[x][y][0] = ((x/5.0)-4.5);
						points[x][y][1] = ((y/5.0)-4.5);
						points[x][y][2] = (Math.sin((((x/5.0)*40.0)/360.0)*Math.PI*2.0));
					}
				}
				*/
				// load the image and create the mesh-material
				var texture = new THREE.ImageUtils.loadTexture("Data/Tim.bmp");
				material = new THREE.MeshBasicMaterial( { map: texture, side:THREE.DoubleSide } );
				
				// now go create the mesh
				createMesh();
			};
			
			function createMesh() {
				
				var planeGeometry = new THREE.PlaneGeometry(9,9,45,45);
				//var pVerts  = plane.vertices;
				//console.log("verts: "+ pVerts.length);

				// add a uniform for the amplitude
				uniforms = {
						amplitude: {
							type: 'f', // a float
							value: 0
						}
				};
				
				var attributes = {
						displacement: {
							type: 'f', // a float
							value: []  // an empty array
						}
				};

				var vs = document.getElementById("vertexShader").textContent;
				var fs = document.getElementById("fragmentShader").textContent;

				var shaderMaterial = new THREE.ShaderMaterial({
						uniforms:     	uniforms,
						attributes:     attributes,
						vertexShader:   vs,
						fragmentShader: fs
					});
				
				// now populate the array of attributes
				var verts  = planeGeometry.vertices;

				var values = attributes.displacement.value;

				//for (var v = 0; v < verts.length; v++) {
				//	values[v] = Math.random() * 0.25;
				//}
				
				for ( var y=0; y<46; y++ ) {
					for ( var x=0; x<46; x++ ) {
						var sVal = Math.sin((((x/5.0)*40.0)/360.0)*Math.PI*2.0);
						var index = x + 46 * y;
						values[index] =  sVal;
					}
				}

				var mesh = new THREE.Mesh( planeGeometry, shaderMaterial);
				nScene.addToScene(mesh);
			}
			
			// this is the simple callback function we pass to the ParametricGeometry
			// the ParametricGeometry will call this for each slice/stack so that u and v vary from 0..1
			function sineWave ( u, v ) {
				x = u * 9 - 4.5;
				y = v * 9 - 4.5;
				z = Math.sin(u*Math.PI*2.0);
				
				return new THREE.Vector3(x, y, z);
			}
			
			// just create the Parametric geometry and add it to the Scene
			// works, but performance is very slow
			function createMeshParametric() {
			    var paraGeom = new THREE.ParametricGeometry(sineWave, 45, 45);
				var mesh = new THREE.Mesh( paraGeom, material);
				nScene.addToScene(mesh);
				
				var vertices = paraGeom.vertices;
				console.log("verts: " + vertices.length );

			}
			
			// this is the orginal approach, much more akin to the original C++ implementation
			// create a series of quads consisting of two triangles
			// works fine but performance is absymal
			function createMeshByTriangles() {
				
				for( var x = 0; x < 44; x++ )
				{
					for( var y = 0; y < 44; y++ )
					{
						var tx1 = (x)/44.0;
						var ty1 = (y)/44.0;
						var tx2 = (x+1)/44.0;
						var ty2 = (y+1)/44.0;
						
						addTriangle(x, y,x+1, y, x, y+1, tx1, ty1,tx2, ty1, tx1, ty2, material);
						
						addTriangle(x+1, y, x+1, y+1, x, y+1, tx2,ty1, tx2, ty2, tx1, ty2, material);

					}
				}
			}
		
			// add one half of each quad as a simple triangle
			function addTriangle ( x1, y1, x2, y2, x3, y3, u1, v1, u2, v2, u3, v3, meshMat ) {
				
				// create a plain Geometry and push the vertices into it
				var triGeom = new THREE.Geometry();
				triGeom.vertices.push(new THREE.Vector3(points[x1][y1][0], points[x1][y1][1], points[x1][y1][2]));
				triGeom.vertices.push(new THREE.Vector3(points[x2][y2][0], points[x2][y2][1], points[x2][y2][2]));
				triGeom.vertices.push(new THREE.Vector3(points[x3][y3][0], points[x3][y3][1], points[x3][y3][2]));

				// now need to create the mapping between our texture and the two triangles that
				// comprise the faces.  For a good intro into UV mapping, see
				// http://solutiondesign.com/webgl-and-three-js-texture-mapping/
				
				var uvs = [];
				uvs.push( new THREE.Vector2( u1,v1 ) );
				uvs.push( new THREE.Vector2( u2,v2 ) );
				uvs.push( new THREE.Vector2( u3,v3 ) );
				
				// create a new Face, whose indices point into the vertices we created above
				triGeom.faces.push( new THREE.Face3( 0, 1, 2 ) );
				// then set corresponding UV vertices
				triGeom.faceVertexUvs[ 0 ].push( [ uvs[0], uvs[1], uvs[2] ] );
				
				// re-compute the normals for both the faces and vertexes
				triGeom.computeFaceNormals();
				triGeom.computeVertexNormals();

				// and create the actual mesh
				var mesh = new THREE.Mesh( triGeom, meshMat);
				// and add it to the scene
				nScene.addToScene(mesh);
			}
			
			// move the points over one step to "wiggle" the mesh
			function wiggleTheMesh() {
				console.log("Wiggle count: " + wiggle_count);
				if ( wiggle_count++ == 2 )
				{
					for ( y = 0; y < 45; y++ )
					{
						var temp = points[0][y][2];
						for ( x = 0; x < 44; x++ )
						{
							points[x][y][2] = points[x+1][y][2];
						}
						points[44][y][2] = temp;
					}
					wiggle_count = 0;
				}
			}
			
			/**
			 * Animate the scene and call rendering.
			 */
			var frame = 0;

			function animateScene() {

				// Tell the browser to call this function when page is visible
				requestAnimationFrame(animateScene);

				// update the amplitude based on the frame value.
				uniforms.amplitude.value = Math.sin(frame);
				// bump the frame counter
				frame += 0.1;

				// re-create the mesh - this is an expensive operation.  How to avoid it?
				//createMesh();
				
				// then wiggle the mesh for next time
				//wiggleTheMesh();
				
				// Map the 3D scene down to the 2D screen (render the frame)
				nScene.renderScene();
			}
		</script>
	</body>
</html>
