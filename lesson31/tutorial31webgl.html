<!DOCTYPE html>	<!-- Tells the browser that the page uses the HTML5 standard -->
<html>
	<head>
		<!-- -------------------------------------
  			Roughly based (or inspired by) NeHe Tutorial xxx 
  			Original:  http://nehe.gamedev.net/tutorial/model_loading/16004/
  
  			@author: rkwright@geofx.com
		-------------------------------------- -->
		<title>NEHE Tutorial 31</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

		<!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
		<link rel="stylesheet" type="text/css" href="../css/NEHE.css" /> 

		<!-- Include several libraries from THREE.js and the Scene class  -->
		<script src="../js/three.js" type="text/javascript"></script>
		<script src="../js/Detector.js" type="text/javascript"></script>
		<script src="../js/OrbitControls-Touch-Ortho.js" type="text/javascript"></script>
		<script src="../js/Stats.js" type="text/javascript"></script>
		<script src="../js/gfx-scene.js" type="text/javascript"></script>
        <script src="js/OBJLoader.js" type="text/javascript"></script>
        <script src="js/ColladaLoader.js" type="text/javascript"></script>
        <script src="js/AWDLoader.js"></script>
        <script src="js/BabylonLoader.js"></script>
        <script src="js/PDBLoader.js"></script>
        <!-- script src="js/PLYLoader.js"></script>
        <script src="js/STLLoader.js"></script>
        <script src="js/VRMLLoader.js"></script>
        <script src="js/VTKLoader.js"></script -->
	</head>
	<body>	
		<script type="text/javascript">
			var	    modelMesh;
			var     modelType;
	
			// allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
			var gfxScene = new GFX.Scene( {
                cameraPos : [5, 5, 10],
                axesHeight:10,
				controls:true,
				displayStats:true});
	
			// then initialize our demo's stuff
			initializeDemo();
	
			// Animate the scene
			animateScene();
	
			/**
			 * Initialize the Demo.  
			 */
	
			function initializeDemo() {

			    loadModel('4');

                document.addEventListener("keypress", onDocumentKeyPress, false);
            }

            function loadModel( type ) {

                modelType = type;

                gfxScene.remove( modelMesh );

                switch ( modelType ) {
                    case '0':
                        loadCollada();
                        break;
                    case '1':
                        loadOBJ();
                        break;
                    case '2':
                        loadAWD();
                        break;
                    case '3':
                        loadBabylon();
                        break;
                    case '4':
                        loadPDB();
                        break;
                }
            }

			function loadOBJ() {
                var manager = new THREE.LoadingManager();
                //Loader for Obj from Three.js
                var loader = new THREE.OBJLoader( manager );

                //Launch loading of the obj file, addBananaInScene is the callback when it's ready
                loader.load( 'models/OBJ/banana.obj', onLoadOBJ);
			}

            function onLoadOBJ (object) {
                var bbs = getBoundingSphere( object );

                moveObjectToOrigin(object, bbs, 1);

                //Go through all children of the loaded object and search for a Mesh
                object.traverse( function ( child ) {
                    //This allow us to check if the children is an instance of the Mesh constructor
                    if (child instanceof THREE.Mesh){
                        child.material.color = new THREE.Color(0XFFFF00);
                        // Sometimes there are some vertex normals missing in the .obj files, three.js will compute them
                        child.geometry.computeVertexNormals();
                    }
                });

                modelMesh = object;
                //modelMesh.scale.set(1,1,1);
                gfxScene.add(modelMesh);
                updateLabel("OBJ");
            }

            function  loadCollada () {
                var manager = new THREE.LoadingManager();
                // Loader for Collada from Three.js
                var loader = new THREE.ColladaLoader( manager );

                // Launch loading of the Collada file, onLoadCollada will be called when it's ready
                loader.load( 'models/Collada/Shark.dae', onLoadCollada);
            }

            function onLoadCollada( object ) {
                dae = object.scene;
               // var bbs = getBoundingSphere( german );

               // moveObjectToOrigin(german, bbs, 1);

                // Go through all children of the loaded object and search for a Mesh
                dae.traverse( function ( child ) {
                    //This allow us to check if the children is an instance of the Mesh constructor
                    if (child instanceof THREE.Mesh){
                        child.material.color = new THREE.Color(0X00FF00);
                        // Sometimes there are some vertex normals missing in the .obj files, three.js will compute them
                        child.geometry.computeVertexNormals();
                    }
                });

                modelMesh = dae;
                modelMesh.scale.set(0.5,0.5,0.5);
                modelMesh.rotateX(-Math.PI/2);
                modelMesh.rotateZ(Math.PI/2);
                gfxScene.add(modelMesh);
                updateLabel("Collada");
            }

            function  loadAWD () {
                var manager = new THREE.LoadingManager();
                var loader = new THREE.AWDLoader( manager );

                // Launch loading of the AWD file, onLoadAWD will be called when it's ready
                loader.load( 'models/AWD/simple.awd', onLoadAWD);
            }

            function onLoadAWD ( object ) {
                awd = object;
                // var bbs = getBoundingSphere( german );

                // moveObjectToOrigin(german, bbs, 1);

                // Go through all children of the loaded object and search for a Mesh
                awd.traverse( function ( child ) {
                    //This allow us to check if the children is an instance of the Mesh constructor
                    if (child instanceof THREE.Mesh){
                        child.material.color = new THREE.Color(0X00FF00);
                        // Sometimes there are some vertex normals missing in the .obj files, three.js will compute them
                        child.geometry.computeVertexNormals();
                    }
                });

                modelMesh = awd;
                //modelMesh.position.set(-10, 1, -15);
                modelMesh.scale.set(0.1, 0.1, 0.1);
                gfxScene.add(modelMesh);
                updateLabel("AWD");
            }

            function  loadBabylon () {
                var manager = new THREE.LoadingManager();
                var loader = new THREE.BabylonLoader( manager );

                // Launch loading of the Babylon file, onLoadBabylon will be called when it's ready
                loader.load( 'models/Babylon/rabbit.babylon', onLoadBabylon);
            }

            function onLoadBabylon ( object ) {
			    babylon = object;
                // apply custom material
                object.traverse( function(child) {
                    if (child instanceof THREE.Mesh) {

                        // apply custom material (texture)
                        var textureD = THREE.ImageUtils.loadTexture('models/Babylon/0.jpg', undefined, function() {

                            child.material = new THREE.MeshLambertMaterial({  map: textureD });
                            //child.position.set(0, 0, 0);
                            //child.rotateY(Math.PI);
                            //child.scale.set(0.05, 0.05, 0.05);
                        });
                        textureD.needsUpdate = true;
                        textureD.magFilter = THREE.NearestFilter;
                        textureD.repeat.set(1, 1);
                        textureD.wrapS = textureD.wrapT = THREE.RepeatWrapping;
                        textureD.anisotropy = 16;
                    }
                });

                modelMesh = babylon;
                //modelMesh.position.set(-10, 1, -15);
                modelMesh.rotateY(Math.PI);
                modelMesh.scale.set(0.05, 0.05, 0.05);
                gfxScene.add(modelMesh);
                updateLabel("Babylon");
            }


            function  loadPDB () {
                var manager = new THREE.LoadingManager();
                var loader = new THREE.PDBLoader( manager );

                // Launch loading of the Babylon file, onLoadBabylon will be called when it's ready
                loader.load( 'models/PDB/caf2.pdb', onLoadPDB);
            }

            function onLoadPDB ( geometry, geometryBonds ) {           // prepare PDB loader and load the model
                var group = new THREE.Object3D();

                var i = 0;
                geometry.vertices.forEach(function (position) {
                    var sphere = new THREE.SphereGeometry(0.3);
                    var material = new THREE.MeshPhongMaterial({color: geometry.colors[i++]});
                    var mesh = new THREE.Mesh(sphere, material);
                    mesh.position.copy(position);
                    group.add(mesh);
                });

                for (var j = 0; j < geometryBonds.vertices.length; j += 2) {
                    var path = new THREE.SplineCurve3([geometryBonds.vertices[j], geometryBonds.vertices[j + 1]]);
                    var tube = new THREE.TubeGeometry(path, 1, 0.05)
                    var material = new THREE.MeshPhongMaterial({color: 0xcccccc});
                    var mesh = new THREE.Mesh(tube, material);
                    group.add(mesh);
                }

                modelMesh = group;
                modelMesh.scale.set(0.5, 0.5, 0.5);
                gfxScene.add(group);
                updateLabel("PDB");
            }

            //================= Utilities ==========================

            function updateLabel( modelStr ) {
                document.getElementById("modelType").innerHTML = modelStr;
            }

            function getBoundingSphere ( object ) {
                var helper = new THREE.BoxHelper(object, 0xff0000);

                var bbs = helper.geometry.boundingSphere;
                console.log(bbs.center.x + " " +  bbs.center.y + " " + bbs.center.z);
                console.log(bbs.radius);

                return bbs;
            }

            function moveObjectToOrigin ( object, bbs, size ) {
                scaleVal = size / bbs.radius;
                object.translateX( -bbs.center.x * scaleVal );
                object.translateY( -bbs.center.y * scaleVal );
                object.translateZ( -bbs.center.z * scaleVal );

                object.scale.x = object.scale.y = object.scale.z = scaleVal;

                //var marker = new THREE.Mesh(new THREE.SphereGeometry( 0.25 ), new THREE.MeshBasicMaterial({color: 0xFF0000}));
                //marker.position.set(object.position.x,object.position.y,object.position.z);
                //gfxScene.add(marker);

            }

            function onDocumentKeyPress(event) {
				// Get the key code of the pressed key
				var keyChar = String.fromCharCode(event.which);
                var modelString = "0123456789ab";

                if ( modelString.indexOf(keyChar) != -1) {
                    loadModel(keyChar);
                }
			}
	
			/**
			 * Animate the scene and call rendering.
			 */
			function animateScene() {
	
				// Tell the browser to call this function when page is visible
				requestAnimationFrame(animateScene);
				
				// Map the 3D scene down to the 2D screen (render the frame)
				gfxScene.renderScene();
			}

		</script>

		<!-- Create a DIV element, which will be shown over the WebGL canvas. -->
		<div style="position: absolute; top: 10px; left: 10px;color:white">
			<span>Choose which model: 0...8</span><br/>
			Model: <span id="modelType">XX</span>
		</div>
	</body>
</html>
