<!DOCTYPE html>	<!-- Tells the browser that the page uses the HTML5 standard -->
<html>
	<head>
		<!-- -------------------------------------
  			Roughly based (or inspired by) NeHe Tutorial xxx 
  			Original:  http://nehe.gamedev.net/tutorial/model_loading/16004/
  
  			@author: rkwright@geofx.com
		-------------------------------------- -->
		<title>NEHE Tutorial 31</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

		<!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
		<link rel="stylesheet" type="text/css" href="../css/NEHE.css" /> 

		<!-- Include several libraries from THREE.js and the Scene class  -->
		<script src="../js/three.js" type="text/javascript"></script>
		<script src="../js/Detector.js" type="text/javascript"></script>
		<script src="../js/OrbitControls-Touch-Ortho.js" type="text/javascript"></script>
		<script src="../js/stats.min.js" type="text/javascript"></script>
		<script src="../js/gfx-scene.js" type="text/javascript"></script>
        <script src="js/OBJLoader.js" type="text/javascript"></script>
        <script src="js/ColladaLoader.js" type="text/javascript"></script>
        <!--script src="js/AWDLoader.js"></script>
        <script src="js/BabylonLoader.js"></script>
        <script src="js/PDBLoader.js"></script>
        <script src="js/PLYLoader.js"></script>
        <script src="js/STLLoader.js"></script>
        <script src="js/VRMLLoader.js"></script>
        <script src="js/VTKLoader.js"></script -->
	</head>
	<body>	
		<script type="text/javascript">
			var	 cubeMesh;
	
			// allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
			var gfxScene = new GFX.Scene( {
                cameraPos : [0, 0, 20],
                axesHeight:10,
				controls:true,
				displayStats:true});
	
			// then initialize our demo's stuff
			initializeDemo();
	
			// Animate the scene
			animateScene();
	
			/**
			 * Initialize the Demo.  
			 */
	
			function initializeDemo() {
	
				//loadCollada();

			    loadOBJ();

                //addCube();


                document.addEventListener("keypress", onDocumentKeyPress, false);
            }
	
			function loadOBJ() {
                var manager = new THREE.LoadingManager();
                //Loader for Obj from Three.js
                var loader = new THREE.OBJLoader( manager );

                //Launch loading of the obj file, addBananaInScene is the callback when it's ready
                loader.load( 'models/banana.obj', addObjectToScene);
			}

            function addObjectToScene (object){
                var bbs = getBoundingSphere( object );

                moveObjectToOrigin(object, bbs, 1);

                //Go through all children of the loaded object and search for a Mesh
                object.traverse( function ( child ) {
                    //This allow us to check if the children is an instance of the Mesh constructor
                    if (child instanceof THREE.Mesh){
                        child.material.color = new THREE.Color(0X00FF00);
                        // Sometimes there are some vertex normals missing in the .obj files, three.js will compute them
                        child.geometry.computeVertexNormals();
                    }
                });
                //Add the 3D object in the scene
                gfxScene.add(object);
            }

            function getBoundingSphere ( object ) {
                var helper = new THREE.BoxHelper(object, 0xff0000);

                var bbs = helper.geometry.boundingSphere;
                console.log(bbs.center.x + " " +  bbs.center.y + " " + bbs.center.z);
                console.log(bbs.radius);

                return bbs;
            }

            function moveObjectToOrigin ( object, bbs, size ) {
                scaleVal = size / bbs.radius;
                object.translateX( -bbs.center.x * scaleVal );
                object.translateY( -bbs.center.y * scaleVal );
                object.translateZ( -bbs.center.z * scaleVal );

                object.scale.x = object.scale.y = object.scale.z = scaleVal;

                //var marker = new THREE.Mesh(new THREE.SphereGeometry( 0.25 ), new THREE.MeshBasicMaterial({color: 0xFF0000}));
                //marker.position.set(object.position.x,object.position.y,object.position.z);
                //gfxScene.add(marker);

            }

            function  loadCollada () {
                var manager = new THREE.LoadingManager();
                // Loader for Collada from Three.js
                var loader = new THREE.ColladaLoader( manager );

                // Launch loading of the Collada file, addColladaToScene is the callback when it's ready
                loader.load( 'models/Shark/Shark.dae', addColladaToScene);
            }

            function addColladaToScene( object ) {
                dae = object.scene;
               // var bbs = getBoundingSphere( german );

               // moveObjectToOrigin(german, bbs, 1);

                // Go through all children of the loaded object and search for a Mesh
                dae.traverse( function ( child ) {
                    //This allow us to check if the children is an instance of the Mesh constructor
                    if (child instanceof THREE.Mesh){
                        child.material.color = new THREE.Color(0X00FF00);
                        // Sometimes there are some vertex normals missing in the .obj files, three.js will compute them
                        child.geometry.computeVertexNormals();
                    }
                });
                //Add the 3D object in the scene
                gfxScene.add(dae);
            }

            function onDocumentKeyPress(event) {
				// Get the key code of the pressed key
				var keyChar = String.fromCharCode(event.which);
			}
	
			/**
			 * Animate the scene and call rendering.
			 */
			function animateScene() {
	
				// Tell the browser to call this function when page is visible
				requestAnimationFrame(animateScene);
				
				// Map the 3D scene down to the 2D screen (render the frame)
				gfxScene.renderScene();
			}

		</script>

		<!-- Create a DIV element, which will be shown over the WebGL canvas. -->
		<div style="position: absolute; top: 10px; left: 10px;color:red">
			<br/>
			'model: m, x' model type: with mat, w/o mat 
		</div>
	</body>
</html>
