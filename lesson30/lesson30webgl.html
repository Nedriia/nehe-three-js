<!DOCTYPE html>	<!-- Tells the browser that the page uses the HTML5 standard -->
<html>
	<head>
		<!-- -------------------------------------
  			Roughly based (or inspired by) NeHe Tutorial 30
  			Original:  http://nehe.gamedev.net/tutorial/collision_detection/17005/
  
  			@author: rkwright@geofx.com
		-------------------------------------- -->
		<title>NEHE Lesson 30</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

		<!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
		<link rel="stylesheet" type="text/css" href="../css/NEHE.css" /> 

		<!-- Include several libraries from THREE.js and the Scene class  -->
		<script src="../js/three.js" type="text/javascript"></script>
		<script src="../js/Detector.js" type="text/javascript"></script>
		<script src="../js/OrbitControls-Touch.js" type="text/javascript"></script>
		<script src="../js/Stats.js" type="text/javascript"></script>
        <script src="../js/gfx-scene.js" type="text/javascript"></script>
	</head>
	<body>	
		<script type="text/javascript">
            var box;
            var walls = [];
            var objects = [];
            var incrementX = 0.05;
			// allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
			var gfxScene = new GFX.Scene( {
			    cameraPos : [2, 8, 20],
                axesHeight: 30,
                controls:true,
                displayStats:true
            });

            // then initialize our demo's stuff
			initializeDemo();
	
			// Animate the scene
			animateScene();
	
			/**
			 * Initialize the Demo.  
			 */
			function initializeDemo() {

                createFloorAndWalls();

                createBox();

                gfxScene.renderScene();

                checkIntersections();

                document.addEventListener("keypress", onDocumentKeyPress, false);
			}

            function createBox() {

                var geom = new THREE.BoxGeometry( 1,1,1 );
                var material = new THREE.MeshLambertMaterial( { color: 0xff0000, shading: THREE.FlatShading, opacity:0.5, transparent:true  } );
                var box = new THREE.Mesh( geom, material );
                box.position.set(0, 1, 0);
                objects.push(box);
                gfxScene.add(box);
            }

            function createPartitions() {

                var geom = new THREE.BoxGeometry( 20, 20, 1 );
                var material = new THREE.MeshLambertMaterial( { color: 0x008000, shading: THREE.FlatShading  } );
                mesh = new THREE.Mesh( geom, material );
                mesh.position.set(0, 0, -20);
                walls.push(mesh);
                gfxScene.add(mesh);
            }

			function createFloorAndWalls() {
			    var FLOOR_S = 5;
			    var FLOOR_T = 5;
			    var WALL_S  = 2;
			    var WALL_T  = 2;

                var planeGeo = new THREE.PlaneGeometry( 20, 20 );

                var floorMat = new THREE.MeshStandardMaterial( {
                    roughness: 0.8,
                    color: 0xffffff,
                    bumpScale: 0.0005
                });

                var floorGeom = new THREE.BoxGeometry(20,20,0.5);
                var textureLoader = new THREE.TextureLoader();
                textureLoader.load( "images/hardwood2_diffuse.jpg", function( texture ) {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.anisotropy = 4;
                    texture.repeat.set( FLOOR_S, FLOOR_T );
                    floorMat.side = THREE.DoubleSide;
                    floorMat.map = texture;
                    floorMat.needsUpdate = true;
                } );
                textureLoader.load( "images/hardwood2_bump.jpg", function( texture ) {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.anisotropy = 4;
                    texture.repeat.set( FLOOR_S, FLOOR_T );
                    floorMat.side = THREE.DoubleSide;
                    floorMat.bumpMap = texture;
                    floorMat.needsUpdate = true;
                } );

                textureLoader.load( "images/hardwood2_roughness.jpg", function( texture ) {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.anisotropy = 4;
                    texture.repeat.set( FLOOR_S, FLOOR_T );
                    floorMat.side = THREE.DoubleSide;
                    floorMat.roughnessMap = texture;
                    floorMat.needsUpdate = true;
                } );

                var planeFloor = new THREE.Mesh( planeGeo, floorMat );
                planeFloor.name = "floor";
                planeFloor.rotation.x = -Math.PI / 2.0;
                planeFloor.updateMatrixWorld();
                walls.push(planeFloor);
                gfxScene.add( planeFloor );

                // walls

                var planeTop = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );
                planeTop.name = "top";
                planeTop.position.y = 20;
                planeTop.rotateX( Math.PI / 2 );
                planeTop.updateMatrixWorld();
                walls.push(planeTop);
                gfxScene.add( planeTop );

                var planeBack = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x808080 } ) );
                planeBack.name = "back";
                planeBack.position.z = -10;
                planeBack.position.y = 10;
                planeTop.updateMatrixWorld();
                walls.push(planeBack);
                gfxScene.add( planeBack );

                var planeFront = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );
                planeFront.name = "front";
                planeFront.position.z = 10;
                planeFront.position.y = 10;
                planeFront.rotateY( Math.PI );
                planeFront.updateMatrixWorld();
                walls.push(planeFront);
                gfxScene.add( planeFront );

                var planeRight = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x00ff00 } ) );
                planeRight.name = "right";
                planeRight.position.x = 10;
                planeRight.position.y = 10;
                planeRight.rotateY( - Math.PI / 2 );
                planeRight.updateMatrixWorld();
                walls.push(planeRight);
                gfxScene.add( planeRight );

                var planeLeft = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xff0000 } ) );
                planeLeft.name = "left";
                planeLeft.position.x = -10;
                planeLeft.position.y = 10;
                planeLeft.rotateY( Math.PI / 2 );
                planeLeft.updateMatrixWorld();
                walls.push(planeLeft);
                gfxScene.add( planeLeft );
            }

            /**
             * Just a handler for the keypress event to control parameters of the demo
             */
			function onDocumentKeyPress(event) {
				// Get the key code of the pressed key
				var keyChar = String.fromCharCode(event.which);
                keyChar = keyChar.toLowerCase();

				var renderString = "012";

					if ( renderString.indexOf(keyChar) != -1) {
                    }
			}

			function checkIntersections() {
                for (var i=0; i<objects.length; i++) {
                    var mesh = objects[i];
                    var geom = mesh.geometry;
                    var originPoint = mesh.position.clone();
                    //console.log(" origin: " + originPoint.x + ", " + originPoint.y + ", " + originPoint.z);
                    for ( var vertexIndex = 0; vertexIndex < geom.vertices.length; vertexIndex++ )
                    {
                        var localVertex = geom.vertices[vertexIndex].clone();
                        var globalVertex = localVertex.applyMatrix4( mesh.matrix );
                        var directionVector = globalVertex.sub( mesh.position );

                        var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
                        var collisionResults = ray.intersectObjects( walls );

                       // var color = collisionResults.length > 0 ? 0x0000ff : 0xffff00;
                        //var arrowHelper = new THREE.ArrowHelper( directionVector.clone().normalize(), originPoint, 30, color );
                        //gfxScene.add( arrowHelper );

                        if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) {
                            incrementX = -incrementX;
                            break;

                            //console.log("Hit: " + collisionResults.length);
                            for ( var n=0; n<collisionResults.length; n++ ) {
                                var c = collisionResults[n];
                                //console.log(" vertex: " + globalVertex.x + ", " + globalVertex.y + ", " + globalVertex.z +
                                //" name: " + c.object.name + " dist: " + c.distance + " point: " + c.point.x + ", " + c.point.y + ", " + c.point.z );

                                /*
                                var hpGeom = new THREE.SphereGeometry(0.1);
                                var hpMat = new THREE.MeshBasicMaterial({color: 0xff0000});
                                var hpMesh = new THREE.Mesh(hpGeom, hpMat);
                                hpMesh.position = new THREE.Vector3(c.point.x, c.point.y,c.pointz);
                                gfxScene.add(hpMesh);
                                */
                            }
                        }
                        //else {
                        //    console.log(" Missed! vertex: " + globalVertex.x + ", " + globalVertex.y + ", " + globalVertex.z);
                        //}
                    }
                }
            }

            function updatePositions() {
                for (var i = 0; i < objects.length; i++) {
                    var mesh = objects[i];
                    mesh.position.x += incrementX;
                    mesh.updateMatrixWorld();

                    checkIntersections();

                }
            }

			/**
			 * Animate the scene and call rendering.
			 */
			function animateScene() {

                // Tell the browser to call this function when page is visible
				requestAnimationFrame(animateScene);

                // Map the 3D scene down to the 2D screen (render the frame)
				gfxScene.renderScene();

				updatePositions();
           }

		</script>

		<!-- Create a DIV element, which will be shown over the WebGL canvas. -->
		<div style="position: absolute; top: 10px; left: 10px;color:white">
		<br/>
        </div>
	</body>
</html>
