<!DOCTYPE html>
<html>
	<head>
		<title>Cube Camera Bug</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8">

		<!-- The following meta line optimizes the site for mobile devices. It sets the viewport size
		to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
        <link rel="stylesheet" type="text/css" href="../css/NEHE.css" />

		<!-- Include the necessary libs -->
		<!-- script src="../js/three-75.js" type="text/javascript"></script -->
		<!-- script src="https://threejs.org/build/three.min.js"></script -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r68/three.js"></script>
        <script src="../js/Detector.js" type="text/javascript"></script>
        <script src="../js/OrbitControls-Touch.js" type="text/javascript"></script>
        <script src="../js/Stats.js" type="text/javascript"></script>
        <script src="../js/gfx-scene.js" type="text/javascript"></script>

	</head>
	<body>
    <!-- Create a DIV element, which will be shown over the WebGL canvas. The last line
    ("Renderer: ") will be completed either by "WebGL Renderer" or by "Canvas Renderer". -->

		<script type="text/javascript">
            // a basic three.js scene

            var container, renderer, scene, camera, controls;

            init();
            animate();

            function init() {

                // renderer
                renderer = new THREE.WebGLRenderer({ antialias: false });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0xccccff);
                container = document.createElement('div');
                document.body.appendChild(container);
                container.appendChild(renderer.domElement);

                // scene
                scene = new THREE.Scene();

                // camera
                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
                camera.position.set(0, 10, 10);
                camera.lookAt(scene.position);

                // (camera) controls
                // mouse controls: left button to rotate,
                //    mouse wheel to zoom, right button to pan
                controls = new THREE.OrbitControls(camera, renderer.domElement);

                // light
                var light = new THREE.PointLight(0xffffff);
                light.position.set(10, 25, 25);
                scene.add(light);

                var sphereGeom =  new THREE.SphereGeometry( 2, 32, 32 );
                sphereCamera = new THREE.CubeCamera( 0.1, 5000, 512 );
                scene.add( sphereCamera );

                var sphereMaterial = new THREE.MeshBasicMaterial( { envMap: sphereCamera.renderTarget} );
                mirrorSphere = new THREE.Mesh( sphereGeom, sphereMaterial );
                mirrorSphere.position.set(0, 2, 0);
                sphereCamera.position.copy(mirrorSphere.position);
                scene.add(mirrorSphere);

                var floorTexture = new THREE.ImageUtils.loadTexture( 'images/checkerboard.jpg' );
                floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
                floorTexture.repeat.set( 10, 10 );
                var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side:THREE.DoubleSide } );
                var floorGeometry = new THREE.PlaneGeometry(10, 10, 10, 10);
                var floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = Math.PI / 2;
                scene.add(floor);

                // events
                window.addEventListener('resize', onWindowResize, false);

            }

            function onWindowResize(event) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function animate() {
                controls.update();

                mirrorSphere.visible = false;
                sphereCamera.updateCubeMap( renderer, scene );
                mirrorSphere.visible = true;

                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }
		</script>
	</body>
</html>
