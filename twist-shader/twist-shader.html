<!-- -------------------------------------
  Shader tutorial based on aero-twise 2
  
  @author: rkwright@geofx.com
-------------------------------------- -->
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>Twist-Shader</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

		<!-- The following meta line optimizes the site for mobile devices. It sets the viewport size
		to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
		<link rel="stylesheet" type="text/css" href="NEHE.css" /> 

		<!-- Include two libraries from THREE.js: Core and the Detector for WebGL -->
		<script src="../js/three.js" type="text/javascript"></script>
		<script src="../js/Detector.js" type="text/javascript"></script>
		<script src="../js/OrbitControls.js" type="text/javascript"></script>
		<script src="Scene.js" type="text/javascript"></script>
		
		<script id="vertexShader" type="shader">
			// create a shared variable for the VS and FS containing the normal
			varying vec3     vNormal;
			attribute float  displacement;
			uniform float    amplitude;
			
			void main() {
				// set the vNormal value with the attribute value passed in by Three.js
  				vNormal = normal;

 				// push the displacement into the three slots of a 3D vector so it can
  				// be used in operations with other 3D vectors like positions and normals
 				vec3 newPosition = position + normal * vec3(displacement * amplitude);

  				gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
			}
		</script>
		<script id="fragmentShader" type="shader">
			// create a shared variable for the VS and FS containing the normal
			varying vec3 vNormal;
			precision highp float;

			void main(void) {
				// calculate the dot product and clamp 0 -> 1 rather than -1 -> 1
				  vec3 light = vec3(0.5, 0.2, 1.0);

				  // ensure it's normalized
				  light = normalize(light);

				  // calculate the dot product of the light to the vertex normal
				  float dProd = max(0.0, dot(vNormal, light));

				  // feed into our fragment color
				  gl_FragColor = vec4(dProd, // R
				                      dProd, // G
				                      dProd, // B
				                      1.0);  // A		
			}
		</script>
		
	</head>
	<body>	
		<!-- This JavaScript block encloses the Three.js commands -->
		<script>
			// allocate the Scene object, request orbitControls and an set of 3D axes 10 units high
			var nScene = new Scene( { axisHeight:10, controls:true });
			
			var material;
			var uniforms;
		
			// set up the THREE.js scene via our Scene object
			nScene.initialize();
			
			// then initialize our demo's stuff
			initializeDemo();

			addSphere();
			
			// Animate the scene
			animateScene();

			/**
			 * Initialize the Demo.  This is NeHe #1: http://nehe.gamedev.net/tutorial/flag_effect_%28waving_texture%29/16002/
			 * Create a image mapped texture which is then oscillated (in a sine wave)
			 */
			function initializeDemo() {

				// now go create the mesh
				createMesh();
			};
			
			function addSphere() {
				
				// Sphere parameters: radius, segments along width, segments along height
				var sphereGeometry = new THREE.SphereGeometry( 1, 64, 64 ); 
			
				// add a uniform for the amplitude
				uniforms = {
						amplitude: {
							type: 'f', // a float
							value: 0
						}
				};
				
				var attributes = {
						displacement: {
							type: 'f', // a float
							value: []  // an empty array
						}
				};
				
				var vs = document.getElementById("vertexShader").textContent;
				var fs = document.getElementById("fragmentShader").textContent;

				var shaderMaterial = new THREE.ShaderMaterial({
						uniforms:     	uniforms,
						attributes:     attributes,
						vertexShader:   vs,
						fragmentShader: fs
					});
				

				// now populate the array of attributes
				var verts  = sphereGeometry.vertices;

				var values = attributes.displacement.value;

				for (var v = 0; v < verts.length; v++) {
					values.push(Math.random() * 0.25);
				}

				var sphere = new THREE.Mesh(sphereGeometry, shaderMaterial);
				
				sphere.position.set(1, 1, 1);
				nScene.addToScene(sphere);
			}
			
			function createMesh() {
				
			}
			
			/**
			 * Animate the scene and call rendering.
			 */
			var frame = 0;

			function animateScene() {

				// update the amplitude based on the frame value.
				uniforms.amplitude.value = Math.sin(frame);
				// bump the frame counter
				frame += 0.1;

				// Tell the browser to call this function when page is visible
				requestAnimationFrame(animateScene);
			
				// Map the 3D scene down to the 2D screen (render the frame)
				nScene.renderScene();
			}
		</script>
	</body>
</html>
