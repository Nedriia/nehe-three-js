<!-- -------------------------------------
  NeHe Tutorial 10
  Original:  http://nehe.gamedev.net/tutorial/loading_and_moving_through_a_3d_world/22003/
  
  @author: rkwright@geofx.com
-------------------------------------- -->
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>Three.js/NEHE Tutorial #10</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

		<!-- The following meta line optimizes the site for mobile devices. It sets the viewport size
		to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
		<link rel="stylesheet" type="text/css" href="NEHE.css" /> 

		<!-- Include two libraries from THREE.js: Core and the Detector for WebGL -->
		<script src="../js/three.min.js" type="text/javascript"></script>
		<script src="../js/Detector.js" type="text/javascript"></script>
		<script src="../js/OrbitControls.js" type="text/javascript"></script>
		<script src="Scene.js" type="text/javascript"></script>
		<script src="Data/World.js" type="text/javascript"></script>
	</head>
	<body>	
		<!-- This JavaScript block encloses the Three.js commands -->
		<script>			
	
			// set up the THREE.js scene
			initializeScene();

			// request the orbitControls be created and enabled
			orbitControls();
			
			// then initialize our demo's stuff
			initializeDemo();

			// Animate the scene
			animateScene();

			/**
			 * Initialize the scene.
			 */
			function initializeDemo() {
				
				// draw some 3D axes to orient the user
				drawAxes(10);
		
				// then read the data and create the objects
				createWorld();
			}

			function createWorld() {
				
				// Load an image as texture
				var texture = new THREE.ImageUtils.loadTexture("Data/Sammy.jpg");

				// create the material by mapping our texture onto it.  Note that we map
				// the texture onto both sides of each object
				var material = new THREE.MeshBasicMaterial( { map: texture, side:THREE.DoubleSide } );

				// loop through all the triangles in our "world"
				for ( i=0; i<nTriangles; i++ ) {
					// fetch three rows at a time, being the three vertices
					var i1 = i * 3;
					var i2 = i * 3 + 1;
					var i3 = i * 3 + 2; 
					
					// create a plain Geometry and push the vertices into it
					var triGeom = new THREE.Geometry();
					triGeom.vertices.push(new THREE.Vector3(world[i1][V_X],world[i1][V_Y],world[i1][V_Z]));
					triGeom.vertices.push(new THREE.Vector3(world[i2][V_X],world[i2][V_Y],world[i2][V_Z]));
					triGeom.vertices.push(new THREE.Vector3(world[i3][V_X],world[i3][V_Y],world[i3][V_Z]));

					// now need to create the mapping between our texture and the two triangles that
					// comprise the faces.  For a good intro into UV mapping, see
					// http://solutiondesign.com/webgl-and-three-js-texture-mapping/
					
					var uvs = [];
					// need to see which triangle we are on so we map the correct half of the
					// texture.  Otherwise we end up mapping the same half twice.
					if ((i & 1) == 1) {				
						uvs.push( new THREE.Vector2( 0.0, 1.0 ) );
						uvs.push( new THREE.Vector2( 1.0, 1.0 ) );
						uvs.push( new THREE.Vector2( 1.0, 0.0 ) );
					}
					else {
						uvs.push( new THREE.Vector2( 0.0, 1.0 ) );
						uvs.push( new THREE.Vector2( 0.0, 0.0 ) );
						uvs.push( new THREE.Vector2( 1.0, 0.0 ) );					
					}
					
					// create a new Face, whose indices point into the vertices we created above
					triGeom.faces.push( new THREE.Face3( 0, 1, 2 ) );
					// then set corresponding UV vertices
					triGeom.faceVertexUvs[ 0 ].push( [ uvs[0], uvs[1], uvs[2] ] );
					
					// re-compute the normals for both the faces and vertexes
					triGeom.computeFaceNormals();
					triGeom.computeVertexNormals();

					// and create the actual mesh
					var mesh = new THREE.Mesh( triGeom, material);
					
					// and add it to the scene
					scene.add(mesh);
				}
			}
			
			/**
			 * Animate the scene and call rendering.
			 */
			function animateScene() {

				// Tell the browser to call this function when page is visible
				requestAnimationFrame(animateScene);

				// Map the 3D scene down to the 2D screen (render the frame)
				renderer.render(scene, camera);
				
				// the orbit controls, if used, have to be updated as well
				if (controls != null && typeof controls != 'undefined') 
					controls.update();
			}
		</script>
	</body>
</html>
