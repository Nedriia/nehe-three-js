<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>Three.js/NEHE Tutorial #10</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

		<!-- The following meta line optimizes the site for mobile devices. It sets the viewport size
		to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
		<link rel="stylesheet" type="text/css" href="NEHE.css" /> 

		<!-- Include two libraries from THREE.js: Core and the Detector for WebGL -->
		<script src="../js/three.min.js" type="text/javascript"></script>
		<script src="../js/Detector.js" type="text/javascript"></script>
		<script src="../js/OrbitControls.js" type="text/javascript"></script>
		<script src="Scene.js" type="text/javascript"></script>
		<script src="Data/World.js" type="text/javascript"></script>
	</head>
	<body>
		<!-- This JavaScript block encloses the Three.js commands -->
		<script>
			var xRotation = 0; 			// x and y rotation
			var yRotation = 0;
			var xSpeed = 0.0;			// Rotation speed around x and y axis
			var ySpeed = 0.0;
			var zTranslation = 0.0; 	// Position along the z axis
			
			var lightIsOn = true;  		// Flag for toggling light
			var blendingIsOn = true;	// Flag for toggling blending		
	
			// set up the THREE.js scene
			initializeScene();

			// then initialize our demo's stuff
			initializeDemo();

			// Animate the scene
			animateScene();

			/**
			 * Initialize the scene.
			 */
			function initializeDemo() {
								
				drawAxes(10);

				//drawSphere();
				
				//drawCylinder();
				
				createWorld();

				//draw4();			
			}

			function createWorld() {
				
				// Load an image as texture
				var texture = new THREE.ImageUtils.loadTexture("Data/Sammy.jpg");

				var material = new THREE.MeshBasicMaterial( { map: texture } );
				material.side = THREE.DoubleSide;

				for ( i=0; i<nTriangles; i++ ) {
					var i1 = i * 3;
					var i2 = i * 3 + 1;
					var i3 = i * 3 + 2;
					var triGeom = new THREE.Geometry();
					triGeom.vertices.push(new THREE.Vector3(world[i1][V_X],world[i1][V_Y],world[i1][V_Z]));
					triGeom.vertices.push(new THREE.Vector3(world[i2][V_X],world[i2][V_Y],world[i2][V_Z]));
					triGeom.vertices.push(new THREE.Vector3(world[i3][V_X],world[i3][V_Y],world[i3][V_Z]));

					// need to see which triangle we are on so we map the correct half of the
					// texture.  Otherwise we end up mapping the same half twice.
					var uvs = [];
					if ((i & 1) == 0){				
						uvs.push( new THREE.Vector2( 0.0, 0.0 ) );
						uvs.push( new THREE.Vector2( 1.0, 0.0 ) );
						uvs.push( new THREE.Vector2( 1.0, 1.0 ) );
					}
					else {
						uvs.push( new THREE.Vector2( 0.0, 0.0 ) );
						uvs.push( new THREE.Vector2( 0.0, 1.0 ) );
						uvs.push( new THREE.Vector2( 1.0, 1.0 ) );					
					}
					
					//console.log(i1 + ": " + world[i1][V_X] + ", " + world[i1][V_Y] + ", " + world[i1][V_Z]);
					//console.log(i2 + ": " + world[i2][V_X] + ", " + world[i2][V_Y] + ", " + world[i2][V_Z]);
					//console.log(i3 + ": " + world[i3][V_X] + ", " + world[i3][V_Y] + ", " + world[i3][V_Z]);

					triGeom.faces.push( new THREE.Face3( 0, 1, 2 ) ); // counter-clockwise winding order
					triGeom.faceVertexUvs[ 0 ].push( [ uvs[2], uvs[1], uvs[0] ] );
					
					triGeom.computeFaceNormals();
					triGeom.computeVertexNormals();

					var mesh = new THREE.Mesh( triGeom, material);
					
					scene.add(mesh);
				}
			}
			
			function drawSphere() {
				// Sphere parameters: radius, segments along width, segments along height
				var sphereGeometry = new THREE.SphereGeometry( 0.1, 32, 16 ); 
				// use a "lambert" material rather than "basic" for realistic lighting.
				//   (don't forget to add (at least one) light!)
				var sphereMaterial = new THREE.MeshLambertMaterial( {color: 0x8888ff} ); 
				var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
				sphere.position.set(0, 0, 0);
				scene.add(sphere);
			}
			
			function drawCylinder()
			{
				var geometry = new THREE.CylinderGeometry( 0.5, 0.5, 1.0, 32, 32 ); 
				var material = new THREE.MeshLambertMaterial( {color: "magenta"} ); 
				var cylinder = new THREE.Mesh( geometry, material ); 
				
				cylinder.position.x = -0.5;
				cylinder.rotation.z = Math.PI/2;
				
				scene.add( cylinder );
			}
			function draw4()
			{
				var a = { x:-1, y:-1 }
				var b = { x:1,  y:1 }
		
				var geometry = new THREE.Geometry();
		
				geometry.vertices.push( new THREE.Vector3( a.x, a.y, 0.25 ) );
				geometry.vertices.push( new THREE.Vector3( b.x, a.y, 0.25 ) );
				geometry.vertices.push( new THREE.Vector3( b.x, b.y, 0.25 ) );
				geometry.vertices.push( new THREE.Vector3( a.x, b.y, 0.25 ) );
		
				geometry.faces.push( new THREE.Face3( 0, 1, 2 ) ); // counter-clockwise winding order
//				geometry.faces.push( new THREE.Face3( 0, 2, 3 ) );
		
				geometry.computeFaceNormals();
				geometry.computeVertexNormals();
				
				var material = new THREE.MeshBasicMaterial({ color:"red"});
				material.side = THREE.DoubleSide;
				var mesh = new THREE.Mesh( geometry, material );
				scene.add(mesh);
			}
			
			/**
			 * Animate the scene and call rendering.
			 */
			function animateScene() {

				// Tell the browser to call this function when page is visible
				requestAnimationFrame(animateScene);

				// Map the 3D scene down to the 2D screen (render the frame)
				renderer.render(scene, camera);
				
				controls.update();
			}
		</script>
	</body>
</html>
