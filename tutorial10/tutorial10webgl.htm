<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>Three.js/NEHE Tutorial #10</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

		<!-- The following meta line optimizes the site for mobile devices. It sets the viewport size
		to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
		<link rel="stylesheet" type="text/css" href="NEHE.css" /> 

		<!-- Include two libraries from THREE.js: Core and the Detector for WebGL -->
		<script src="../js/three.min.js" type="text/javascript"></script>
		<script src="../js/Detector.js" type="text/javascript"></script>
	</head>
	<body>
		<!-- Create a DIV element, which will be shown over the WebGL canvas. The last line
		("Renderer: ") will be completed either by "WebGL Renderer" or by "Canvas Renderer". -->
		<div id="overlaytext" style="position: absolute; top: 10px; left: 10px">
			'F': Loop through the three texture filters (only for WebGL renderer)<br/>
			'L': Toggle light (only for WebGL renderer)<br/>
			'B': Toggle blending<br/>
			Cursor left / right: Control y rotation speed<br/>
			Cursor up / down: Control x rotation speed<br/>
			Page up / down: Move along z axis<br/>
			Renderer: "WebGL Renderer"
		</div>

		<!-- This is the DIV element which will contain the WebGL canvas. To be identifiable later on,
		the id 'WebGLCanvas' is applied to it. -->
		<div id="WebGLCanvas"/>

		<!-- This JavaScript block encloses the Three.js commands -->
		<script>
			var scene;					// THREE.js objects	
			var renderer;			
			var camera;	

			var xRotation = 0; 			// x and y rotation
			var yRotation = 0;
			var xSpeed = 0.0;			// Rotation speed around x and y axis
			var ySpeed = 0.0;
			var zTranslation = 0.0; 	// Position along the z axis
			
			var lightIsOn = true;  		// Flag for toggling light
			var blendingIsOn = true;	// Flag for toggling blending		
	
			var cubeMesh;				// cube mesh, material, etc.
			var cubeGeometry;
			var glassTexture;
			var cubeMaterial;
			
			var ambientLight;
			var directionalLight;
			
			// set up the THREE.js scene
			initializeScene();
			
			// Animate the scene
			animateScene();

			/**
			 * Initialize the scene.
			 */
			function initializeScene() {

				// Check whether the browser supports WebGL. 
				if ( !Detector.webgl ) Detector.addGetWebGLMessage();
			
				// allocate the THREE.js renderer
				renderer = new THREE.WebGLRenderer({antialias:true});
			
				// Set the background color of the renderer to black, with full opacity
				renderer.setClearColor(0x000000, 1);
			
				// Get the size of the inner window (content area)
				canvasWidth = window.innerWidth;
				canvasHeight = window.innerHeight;
			
				// Set the renderers size to the content areas size
				renderer.setSize(canvasWidth, canvasHeight);
			
				// Get the DIV element from the HTML document by its ID and append the renderer's DOM object
				document.getElementById("WebGLCanvas").appendChild(renderer.domElement);
			
				// Create the scene, in which all objects are stored (e. g. camera, lights, geometries, ...)
				scene = new THREE.Scene();
				
				camera = new THREE.PerspectiveCamera(45, canvasWidth / canvasHeight, 1, 100);
				camera.position.set(0, 6, 6);
				camera.lookAt(scene.position);
				scene.add(camera);
				
				// Create the cube
				cubeGeometry = new THREE.CubeGeometry(2.0, 2.0, 2.0);

				// Load an image as texture
				glassTexture = new THREE.ImageUtils.loadTexture("Glass.jpg");

				// Create a material, which contains the texture
				cubeMaterial = new THREE.MeshLambertMaterial({
					map:glassTexture,
					depthWrite: false,
					transparent: true,
					opacity: 1.0,
					side:THREE.DoubleSide,
					combine: THREE.MixOperation
				});
				
				// Create a mesh and insert the geometry and the material. Translate the
				// whole mesh by 'zTranslation' units on the z axis. Finally add the mesh
				// to the scene.
				cubeMesh = new THREE.Mesh(cubeGeometry, cubeMaterial);
				cubeMesh.position.set(0.0, 0.0, zTranslation);
				scene.add(cubeMesh);

				// Ambient light has no direction, it illuminates every object with the same
				// intensity. If only ambient light is used, no shading effects will occur.
				ambientLight = new THREE.AmbientLight(0x777777, 1.0);
				scene.add(ambientLight);

				// Directional light has a source and shines in all directions, like the sun.
				// This behaviour creates shading effects.
				directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
				directionalLight.position = camera.position;
				scene.add(directionalLight);

				// Add a listener for 'keydown' events. By this listener, all key events will be
				// passed to the function 'onDocumentKeyDown'. There's another event type 'keypress'.
				// It will report only the visible characters like 'a', but not the function keys
				// like 'cursor up'.
				document.addEventListener("keydown", onDocumentKeyDown, false);
			}

			/**
			 * This function is called, when a key is oushed down.
			 */
			function onDocumentKeyDown(event){
				// Get the key code of the pressed key
				var keyCode = event.which;

			}

			/**
			 * Animate the scene and call rendering.
			 */
			function animateScene() {

				// Update and set the rotation around x and y axis
				xRotation += xSpeed;
				yRotation += ySpeed;
				cubeMesh.rotation.set(xRotation, yRotation, 0.0);

				// Apply the the translation along the z axis
				cubeMesh.position.z = zTranslation;

				// Define the function, which is called by the browser supported timer loop. If the
				// browser tab is not visible, the animation is paused. So 'animateScene()' is called
				// in a browser controlled loop.
				requestAnimationFrame(animateScene);

				// Map the 3D scene down to the 2D screen (render the frame)
				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
