<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>Three.js/NEHE Tutorial #10</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

		<!-- The following meta line optimizes the site for mobile devices. It sets the viewport size
		to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
		<link rel="stylesheet" type="text/css" href="NEHE.css" /> 

		<!-- Include two libraries from THREE.js: Core and the Detector for WebGL -->
		<script src="../js/three.min.js" type="text/javascript"></script>
		<script src="../js/Detector.js" type="text/javascript"></script>
		<script src="../js/OrbitControls.js" type="text/javascript"></script>
		<script src="Scene.js" type="text/javascript"></script>
		<script src="Data/World.js" type="text/javascript"></script>
	</head>
	<body>
		<!-- This JavaScript block encloses the Three.js commands -->
		<script>
			var xRotation = 0; 			// x and y rotation
			var yRotation = 0;
			var xSpeed = 0.0;			// Rotation speed around x and y axis
			var ySpeed = 0.0;
			var zTranslation = 0.0; 	// Position along the z axis
			
			var lightIsOn = true;  		// Flag for toggling light
			var blendingIsOn = true;	// Flag for toggling blending		
	
			// set up the THREE.js scene
			initializeScene();

			// then initialize our demo's stuff
			initializeDemo();

			// Animate the scene
			animateScene();

			/**
			 * Initialize the scene.
			 */
			function initializeDemo() {
								
				drawAxes(10);

				//drawSphere();
				
				//drawCylinder();
				
				createWorld();

				//draw4();			
			}

			function createWorld() {
				
				// Load an image as texture
				var mudTexture = new THREE.ImageUtils.loadTexture("Data/Mud.png");

				var mudMaterial = new THREE.MeshBasicMaterial( {
				    map: mudTexture
				  } );
				mudMaterial.side = THREE.DoubleSide;

				// object will just clamp them to 1, i.e. white

				for ( i=0; i<nTriangles; i++ ) {
					var i1 = i * 3;
					var i2 = i * 3 + 1;
					var i3 = i * 3 + 2;
					var triGeom = new THREE.Geometry();
					triGeom.vertices.push(new THREE.Vector3(world[i1][V_X],world[i1][V_Y],world[i1][V_Z]));
					triGeom.vertices.push(new THREE.Vector3(world[i2][V_X],world[i2][V_Y],world[i2][V_Z]));
					triGeom.vertices.push(new THREE.Vector3(world[i3][V_X],world[i3][V_Y],world[i3][V_Z]));

					var uvs = [];
					uvs.push( new THREE.Vector2( 0.0, 0.0 ) );
					uvs.push( new THREE.Vector2( 1.0, 0.0 ) );
					uvs.push( new THREE.Vector2( 1.0, 1.0 ) );
					
					//console.log(i1 + ": " + world[i1][V_X] + ", " + world[i1][V_Y] + ", " + world[i1][V_Z]);
					//console.log(i2 + ": " + world[i2][V_X] + ", " + world[i2][V_Y] + ", " + world[i2][V_Z]);
					//console.log(i3 + ": " + world[i3][V_X] + ", " + world[i3][V_Y] + ", " + world[i3][V_Z]);

					triGeom.faces.push( new THREE.Face3( 0, 1, 2 ) ); // counter-clockwise winding order
					triGeom.faceVertexUvs[ 0 ].push( [ uvs[0], uvs[1], uvs[2] ] );
					
					triGeom.computeFaceNormals();
					triGeom.computeVertexNormals();
					
					/*
					triGeom.faceVertexUvs[0].push([
					                                new THREE.UV(0, 0),
					                                new THREE.UV(0, 0),
					                                new THREE.UV(0, 0),
					                                new THREE.UV(0, 0)
					                              ]);
					*/
					
					var r    = Math.random();
					var g    = Math.random();
					var b    = Math.random();

					var material = new THREE.MeshBasicMaterial({ color:"red"});
					material.color.setRGB(r, g, b);
					material.side = THREE.DoubleSide;

					var mesh = new THREE.Mesh( triGeom, mudMaterial);
					
					scene.add(mesh);
				}


			}
			
			function drawSphere() {
				// Sphere parameters: radius, segments along width, segments along height
				var sphereGeometry = new THREE.SphereGeometry( 0.1, 32, 16 ); 
				// use a "lambert" material rather than "basic" for realistic lighting.
				//   (don't forget to add (at least one) light!)
				var sphereMaterial = new THREE.MeshLambertMaterial( {color: 0x8888ff} ); 
				var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
				sphere.position.set(0, 0, 0);
				scene.add(sphere);
			}
			
			function drawCylinder()
			{
				var geometry = new THREE.CylinderGeometry( 0.5, 0.5, 1.0, 32, 32 ); 
				var material = new THREE.MeshLambertMaterial( {color: "magenta"} ); 
				var cylinder = new THREE.Mesh( geometry, material ); 
				
				cylinder.position.x = -0.5;
				cylinder.rotation.z = Math.PI/2;
				
				scene.add( cylinder );
			}
			function draw4()
			{
				var a = { x:-1, y:-1 }
				var b = { x:1,  y:1 }
		
				var geometry = new THREE.Geometry();
		
				geometry.vertices.push( new THREE.Vector3( a.x, a.y, 0.25 ) );
				geometry.vertices.push( new THREE.Vector3( b.x, a.y, 0.25 ) );
				geometry.vertices.push( new THREE.Vector3( b.x, b.y, 0.25 ) );
				geometry.vertices.push( new THREE.Vector3( a.x, b.y, 0.25 ) );
		
				geometry.faces.push( new THREE.Face3( 0, 1, 2 ) ); // counter-clockwise winding order
//				geometry.faces.push( new THREE.Face3( 0, 2, 3 ) );
		
				geometry.computeFaceNormals();
				geometry.computeVertexNormals();
				
				var material = new THREE.MeshBasicMaterial({ color:"red"});
				material.side = THREE.DoubleSide;
				var mesh = new THREE.Mesh( geometry, material );
				scene.add(mesh);
			}
			
			function draw(g)
		    {
		        objectContainer = new THREE.Object3D();

		        texture = THREE.ImageUtils.loadTexture('Data/Mud.png');
		        texture.flipY = false;

		        materials = [];
		        materials.push(new THREE.MeshLambertMaterial({
		            map: texture,
		            vertexColors: THREE.VertexColors
		        }));

		        var faceIndices = ['a','b','c','d'];

		        var color = new THREE.Color(0xffffff);
		        color.setHex(0x333333);

		        var uvs = [];
		        uvs.push(new THREE.Vector2(0,1));
		        uvs.push(new THREE.Vector2(0,0));
		        uvs.push(new THREE.Vector2(1,1));
		        uvs.push(new THREE.Vector2(1,0));

		        for (i = 0; i < g.faces.length; i++)
		        {
		            face = g.faces[i];
		            geo = new THREE.Geometry();
		            geo.faces.push(new THREE.Face3(0,1,2));
		            geo.faceVertexUvs[0] = [];
		            geo.faceVertexUvs[0].push([uvs[0], uvs[1], uvs[3]]);
		            geo.faces[0].materialIndex = 0;

		            for (j = 0; j < 3; j++)
		            {
		                fi = face[faceIndices[j]];
		                v = g.vertices[fi];
		                geo.vertices.push(new THREE.Vector3(v.x,v.y,v.z));
		                geo.faces[0].vertexColors[j] = color;
		            }

		            geo.computeVertexNormals(); 
		            geo.computeBoundingBox();

		            obj = new THREE.SceneUtils.createMultiMaterialObject(geo, materials);

		            objectContainer.add(obj);
		        }
		        scene.add(objectContainer);
		    }
			
			/**
			 * Animate the scene and call rendering.
			 */
			function animateScene() {

				// Tell the browser to call this function when page is visible
				requestAnimationFrame(animateScene);

				// Map the 3D scene down to the 2D screen (render the frame)
				renderer.render(scene, camera);
				
				controls.update();
			}
		</script>
	</body>
</html>
