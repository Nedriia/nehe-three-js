<!DOCTYPE html>	<!-- Tells the browser that the page uses the HTML5 standard -->
<html>
<head>
<!-- -------------------------------------
	Roughly based (or inspired by) NeHe Tutorial 19 
	Original:  http://nehe.gamedev.net/tutorial/particle_engine_using_triangle_strips/21001/

	@author: rkwright@geofx.com
-------------------------------------- -->
<title>NEHE Tutorial 19</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

<!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="../css/NEHE.css" /> 

<!-- Include several libraries from THREE.js and the Scene class  -->
<script src="../js/three71.js" type="text/javascript"></script>
<script src="../js/Detector.js" type="text/javascript"></script>
<script src="../js/OrbitControls-Touch.js" type="text/javascript"></script>
<script src="../js/Stats.js" type="text/javascript"></script>
<script src="../js/gfx-scene.js" type="text/javascript"></script>

</head>
<body>	

		
<script type="text/javascript">

    var clock = new THREE.Clock();
    var materials = [];
    var geometry;

	// allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
	var gfxScene = new GFX.Scene( { axisHeight:10, 
						            controls:true, 
						            displayStats:true });
 
	// set up the THREE.js scene via our Scene object
	gfxScene.initialize();

	// then initialize our demo's stuff
	initializeDemo();

	// Animate the scene
	animateScene();

	/**
	 * Initialize the Demo.  
	 */
	function initializeDemo() {

	    createParticles();
	}

    function createParticles() {

        geometry = new THREE.Geometry();

        particleCount = 200;	/* Leagues under the sea */

        /*	Hope you took your motion sickness pills;
         We're about to get loopy.	*/

        for (i = 0; i < particleCount; i++) {

            var vertex = new THREE.Vector3();
            vertex.x = Math.random() * 2000 - 1000;
            vertex.y = Math.random() * 2000 - 1000;
            vertex.z = Math.random() * 2000 - 1000;

            geometry.vertices.push(vertex);
        }

        //	We can't stop here, this is bat country!

        parameters = [
                        [[1, 1, 0.5], 5],
                        [[0.95, 1, 0.5], 4],
                        [[0.90, 1, 0.5], 3],
                        [[0.85, 1, 0.5], 2],
                        [[0.80, 1, 0.5], 1]];

        parameterCount = parameters.length;

        /*	I told you to take those motion sickness pills.
         Clean that vomit up, we're going again!	*/

        for (i = 0; i < parameterCount; i++) {

            color = parameters[i][0];
            size  = parameters[i][1];

            materials[i] = new THREE.PointCloudMaterial({size:size});

            particles = new THREE.PointCloud(geometry, materials[i]);

            particles.rotation.x = Math.random() * 6;
            particles.rotation.y = Math.random() * 6;
            particles.rotation.z = Math.random() * 6;

            gfxScene.add(particles);
        }
    }

    function updateParticles() {

        var time = Date.now() * 0.00005;

       // gfxScene.camera.position.x += (mouseX - gfxScene.camera.position.x) * 0.05;
       // gfxScene.camera.position.y += (- mouseY - gfxScene.camera.position.y) * 0.05;

        gfxScene.camera.lookAt(gfxScene.scene.position);

        for (i = 0; i < gfxScene.scene.children.length; i ++) {

            var object = gfxScene.scene.children[i];

            if (object instanceof THREE.PointCloud) {

                object.rotation.y = time * (i < 4 ? i + 1 : - (i + 1));
            }
        }

        for (i = 0; i < materials.length; i ++) {

            color = parameters[i][0];

            h = (360 * (color[0] + time) % 360) / 360;
            materials[i].color.setHSL(h, color[1], color[2]);
        }
    }

	/**
	 * Animate the scene and call rendering.
	 */
	function animateScene() {

		// Tell the browser to call this function when page is visible
		requestAnimationFrame(animateScene);

        updateParticles();

		// Map the 3D scene down to the 2D screen (render the frame)
		gfxScene.renderScene();
    }

</script>	
<!-- Create a DIV element, which will be shown over the WebGL canvas. -->
<div style="position: absolute; top: 10px; left: 10px;color:red">
	'r': Re-start the animation<br/>
	'+ .. -' : Increase, decrease the volume
</div>
</body>
</html>
