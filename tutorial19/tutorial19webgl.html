<!DOCTYPE html>	<!-- Tells the browser that the page uses the HTML5 standard -->
<html>
<head>
<!-- -------------------------------------
	Roughly based (or inspired by) NeHe Tutorial 19 
	Original:  http://nehe.gamedev.net/tutorial/particle_engine_using_triangle_strips/21001/

	@author: rkwright@geofx.com
-------------------------------------- -->
<title>NEHE Tutorial 18</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

<!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="../css/NEHE.css" /> 

<!-- Include several libraries from THREE.js and the Scene class  -->
<script src="../js/three.js" type="text/javascript"></script>
<script src="../js/Detector.js" type="text/javascript"></script>
<script src="../js/OrbitControls-Touch.js" type="text/javascript"></script>
<script src="../js/Stats.js" type="text/javascript"></script>
<script src="../js/Scene.js" type="text/javascript"></script>

</head>
<body>	
	<!-- -------------- the shaders ------------------------------- -->
<script id="vertexShader" type="x-shader/x-vertex">
	attribute vec3  customColor;
	attribute float customOpacity;
	attribute float customSize;
	attribute float customAngle;
	attribute float customVisible;  	// float used as boolean (0 = false, 1 = true)
	varying vec4  vColor;
	varying float vAngle;
	void main()
	{
		if ( customVisible > 0.5 ) 				// i.e. true
			// set color associated to vertex; use later in fragment shader.
			vColor = vec4( customColor, customOpacity ); 
		else							// false
			// make particle invisible.
			vColor = vec4(0.0, 0.0, 0.0, 0.0); 		
		
		vAngle = customAngle;

		// scale particles as objects in 3D space
		vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
		gl_PointSize = customSize * ( 300.0 / length( mvPosition.xyz ) );     
		gl_Position = projectionMatrix * mvPosition;
	}
</script>
	
<script id="fragmentShader" type="x-shader/x-fragment">
	uniform sampler2D texture;
	varying vec4 vColor; 	
	varying float vAngle;   
	void main() 
	{
		gl_FragColor = vColor;
	
		float c = cos(vAngle);
		float s = sin(vAngle);
		// rotate UV coordinates to rotate texture
		vec2 rotatedUV = vec2(c * (gl_PointCoord.x - 0.5) + s * (gl_PointCoord.y - 0.5) + 0.5, 
	                      c * (gl_PointCoord.y - 0.5) - s * (gl_PointCoord.x - 0.5) + 0.5);  
	    vec4 rotatedTexture = texture2D( texture,  rotatedUV );
	    // sets an otherwise white particle texture to desired color
	    gl_FragColor = gl_FragColor * rotatedTexture;    
	}
</script>
<!-- --------------------------------------------------------------- -->
		
<script type="text/javascript">
	// allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
	var nScene = new Scene( { axisHeight:10, 
						      controls:true, 
						      displayStats:true });

	// set up the THREE.js scene via our Scene object
	nScene.initialize();

	// then initialize our demo's stuff
	initializeDemo();

	// Animate the scene
	animateScene();

	/**
	 * Initialize the Demo.  
	 */
	function initializeDemo() {
		
	}
</script>	
<!-- Create a DIV element, which will be shown over the WebGL canvas. -->
<div style="position: absolute; top: 10px; left: 10px;color:red">
	'0 .. 9': Type of object<br/>
	't, p, w' : texture, paint or wireframe
</div>
</body>
</html>
