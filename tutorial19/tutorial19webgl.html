<!DOCTYPE html>	<!-- Tells the browser that the page uses the HTML5 standard -->
<html>
<head>
<!-- -------------------------------------
	Roughly based (or inspired by) NeHe Tutorial 19 
	Original:  http://nehe.gamedev.net/tutorial/particle_engine_using_triangle_strips/21001/

	@author: rkwright@geofx.com
-------------------------------------- -->
<title>NEHE Tutorial 19</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

<!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="../css/NEHE.css" /> 

<!-- Include several libraries from THREE.js and the Scene class  -->
<script src="../js/three.js" type="text/javascript"></script>
<script src="../js/Detector.js" type="text/javascript"></script>
<script src="../js/OrbitControls-Touch.js" type="text/javascript"></script>
<script src="../js/Stats.js" type="text/javascript"></script>
<script src="../js/gfx-scene.js" type="text/javascript"></script>

</head>
<body>	
	<!-- -------------- the shaders ------------------------------- -->
<script id="vertexShader" type="x-shader/x-vertex">
	attribute vec3  customColor;
	attribute float customOpacity;
	attribute float customSize;
	attribute float customAngle;
	attribute float customVisible;  	// float used as boolean (0 = false, 1 = true)
	varying vec4  vColor;
	varying float vAngle;
	void main()
	{
		if ( customVisible > 0.5 ) 				// i.e. true
			// set color associated to vertex; use later in fragment shader.
			vColor = vec4( customColor, customOpacity ); 
		else							// false
			// make particle invisible.
			vColor = vec4(0.0, 0.0, 0.0, 0.0); 		
		
		vAngle = customAngle;

		// scale particles as objects in 3D space
		vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
		gl_PointSize = customSize * ( 300.0 / length( mvPosition.xyz ) );     
		gl_Position = projectionMatrix * mvPosition;
	}
</script>
	
<script id="fragmentShader" type="x-shader/x-fragment">
	uniform sampler2D texture;
	varying vec4 vColor; 	
	varying float vAngle;   
	void main() 
	{
		gl_FragColor = vColor;
	
		float c = cos(vAngle);
		float s = sin(vAngle);
		// rotate UV coordinates to rotate texture
		vec2 rotatedUV = vec2(c * (gl_PointCoord.x - 0.5) + s * (gl_PointCoord.y - 0.5) + 0.5, 
	                      c * (gl_PointCoord.y - 0.5) - s * (gl_PointCoord.x - 0.5) + 0.5);  
	    vec4 rotatedTexture = texture2D( texture,  rotatedUV );
	    // sets an otherwise white particle texture to desired color
	    gl_FragColor = gl_FragColor * rotatedTexture;    
	}
</script>
<!-- --------------------------------------------------------------- -->
		
<script type="text/javascript">

    var clock = new THREE.Clock();
    var materials = [];
    var geometry;

	// allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
	var gfxScene = new GFX.Scene( { axisHeight:10, 
						            controls:true, 
						            displayStats:true });
 
	// set up the THREE.js scene via our Scene object
	gfxScene.initialize();

	// then initialize our demo's stuff
	initializeDemo();

	// Animate the scene
	animateScene();

	/**
	 * Initialize the Demo.  
	 */
	function initializeDemo() {

	    createParticles();
	}

    function createParticles() {

        geometry = new THREE.Geometry();

        particleCount = 20000;	/* Leagues under the sea */

        /*	Hope you took your motion sickness pills;
         We're about to get loopy.	*/

        for (i = 0; i < particleCount; i++) {

            var vertex = new THREE.Vector3();
            vertex.x = Math.random() * 2000 - 1000;
            vertex.y = Math.random() * 2000 - 1000;
            vertex.z = Math.random() * 2000 - 1000;

            geometry.vertices.push(vertex);
        }

        //	We can't stop here, this is bat country!

        parameters = [[[1, 1, 0.5], 5], [[0.95, 1, 0.5], 4], [[0.90, 1, 0.5], 3], [[0.85, 1, 0.5], 2], [[0.80, 1, 0.5], 1]];
        parameterCount = parameters.length;

        /*	I told you to take those motion sickness pills.
         Clean that vommit up, we're going again!	*/

        for (i = 0; i < parameterCount; i++) {

            color = parameters[i][0];
            size  = parameters[i][1];

            materials[i] = new THREE.PointCloudMaterial({size:size});

            particles = new THREE.PointCloud(geometry, materials[i]);

            particles.rotation.x = Math.random() * 6;
            particles.rotation.y = Math.random() * 6;
            particles.rotation.z = Math.random() * 6;

            gfxScene.add(particles);
        }
    }

    function updateParticles() {

        var time = Date.now() * 0.00005;

       // gfxScene.camera.position.x += (mouseX - gfxScene.camera.position.x) * 0.05;
       // gfxScene.camera.position.y += (- mouseY - gfxScene.camera.position.y) * 0.05;

        gfxScene.camera.lookAt(gfxScene.scene.position);

        for (i = 0; i < gfxScene.scene.children.length; i ++) {

            var object = gfxScene.scene.children[i];

            if (object instanceof THREE.PointCloud) {

                object.rotation.y = time * (i < 4 ? i + 1 : - (i + 1));
            }
        }

        for (i = 0; i < materials.length; i ++) {

            color = parameters[i][0];

            h = (360 * (color[0] + time) % 360) / 360;
            materials[i].color.setHSL(h, color[1], color[2]);
        }
    }

	/**
	 * Animate the scene and call rendering.
	 */
	function animateScene() {

		// Tell the browser to call this function when page is visible
		requestAnimationFrame(animateScene);

        updateParticles();

		// Map the 3D scene down to the 2D screen (render the frame)
		gfxScene.renderScene();
    }

</script>	
<!-- Create a DIV element, which will be shown over the WebGL canvas. -->
<div style="position: absolute; top: 10px; left: 10px;color:red">
	'r': Re-start the animation<br/>
	'+ .. -' : Increase, decrease the volume
</div>
</body>
</html>
