<!doctype html>
<html lang="en">
<head>
	<!-- This demo based on work by Lee Stemkoski, see https://stemkoski.github.io/Three.js -->
	<title>Sprite Text Labels</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="../css/NEHE.css"/>
	
	<script src="../js/Three.js"></script>
	<script src="../js/Detector.js"></script>
	<script src="../js/Stats.js"></script>
	<script src="../js/OrbitControls.js"></script>
	<script src="../js/Scene.js"></script>
</head>
<body>

<script>
//custom global variables
var cube;
var projector, mouse = { x: 0, y: 0 }, INTERSECTED;
var sprite1;
var canvas1, context1, texture1;
var DESCENDER_ADJUST = 1.28;

// allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
var nScene = new Scene( { axisHeight:10, controls:true, displayStats:true });

// set up the THREE.js scene via our Scene object
nScene.initialize();

// then initialize our demo's stuff
initializeDemo();

// Animate the scene
animateScene();

/**
 * Initialize the Demo.  This is roughly equivalent to NeHe #12: 
 */
	
function initializeDemo() 
{
	var cubeGeometry = new THREE.BoxGeometry( 1, 1, 1 );
	var cubeMaterial = new THREE.MeshNormalMaterial( { wireframe:true } );
	cube = new THREE.Mesh( cubeGeometry, cubeMaterial );
	cube.position.set(0,0,0);
	cube.name = "Cube";
	nScene.addToScene(cube);
	
	var materialC = new THREE.SpriteMaterial( { color: 0xff00ff, fog: false } );
	var sprite = new THREE.Sprite( materialC );
	sprite.position.set( 0.5, 0.5, 0.5 );
	sprite.position.normalize();
	sprite.scale.set(0.5, 0.5, 1.0);

	//	nScene.addToScene( sprite );

	var sphere = new THREE.Mesh( new THREE.SphereGeometry(0.01, 32, 32), new THREE.MeshNormalMaterial());
	sphere.position.set(0.5,0.5,0);
	nScene.addToScene(sphere);
	
	sphere = new THREE.Mesh( new THREE.SphereGeometry(0.01, 32, 32), new THREE.MeshNormalMaterial());
	sphere.position.set(-0.5,0.5,0.25);
	nScene.addToScene(sphere);
 
	var spritey = makeTextSprite( "Wiggle!W", { fontsize: 72, fontface: "Georgia", borderColor: {r:0, g:0, b:255, a:1.0}, 
		borderThickness:0, radius:0, vAlign:"top", hAlign:"left" } );
	spritey.position.set(-0.5,-0.5,0.25);
	nScene.addToScene( spritey );
	
	var spritey = makeTextSprite( "Wiggle!W", { fontsize: 72, fontface: "Georgia", borderColor: {r:0, g:0, b:255, a:1.0}, 
		borderThickness:0, radius:0, vAlign:"bottom", hAlign:"right" } );
	spritey.position.set(0.5,0.5,0.25);
	nScene.addToScene( spritey );

	var spritey = makeTextSprite( "Wiggle!W", { fontsize: 72, fontface: "Georgia", borderColor: {r:0, g:0, b:255, a:1.0}, 
		borderThickness:0, radius:0, vAlign:"bottom", hAlign:"left" } );
	spritey.position.set(-0.5,0.5,0.25);
	nScene.addToScene( spritey );
	
	var spritey = makeTextSprite( "Wiggle!W", { fontsize: 72, fontface: "Georgia", borderColor: {r:0, g:0, b:255, a:1.0}, 
		borderThickness:0, radius:0, vAlign:"center", hAlign:"left" } );
	spritey.position.set(-0.5,0,0.25);
	nScene.addToScene( spritey );

	var spritey = makeTextSprite( "Wiggle!W", { fontsize: 72, fontface: "Georgia", borderColor: {r:0, g:0, b:255, a:1.0}, 
		borderThickness:0, radius:0, vAlign:"center", hAlign:"right" } );
	spritey.position.set(0.5,0,0.25);
	nScene.addToScene( spritey );

	var spritey = makeTextSprite( "Wiggle!W", { fontsize: 72, fontface: "Georgia", borderColor: {r:0, g:0, b:255, a:1.0}, 
		borderThickness:0, radius:0, vAlign:"top", hAlign:"right" } );
	spritey.position.set(0.5,-0.5,0.25);
	nScene.addToScene( spritey );

	var spritey = makeTextSprite( "Wiggle!W", { fontsize: 72, fontface: "Georgia", borderColor: {r:0, g:0, b:255, a:1.0}, 
		borderThickness:0, radius:0, vAlign:"bottom", hAlign:"center" } );
	spritey.position.set(0,0.5,0.25);
	nScene.addToScene( spritey );

	var spritey = makeTextSprite( "Wiggle!W", { fontsize: 72, fontface: "Georgia", borderColor: {r:0, g:0, b:255, a:1.0}, 
		borderThickness:0, radius:0, vAlign:"center", hAlign:"center" } );
	spritey.position.set(0,0,0.25);
	nScene.addToScene( spritey );

	var spritey = makeTextSprite( "Wiggle!W", { fontsize: 72, fontface: "Georgia", borderColor: {r:0, g:0, b:255, a:1.0}, 
		borderThickness:0, radius:0, vAlign:"top", hAlign:"center" } );
	spritey.position.set(0,-0.5,0.25);
	nScene.addToScene( spritey );}

function makeTextSprite( message, parameters )
{
	if ( parameters === undefined ) parameters = {};
	
	var fontface = parameters.hasOwnProperty("fontface") ? 
		parameters["fontface"] : "Arial";
	
	var fontsize = parameters.hasOwnProperty("fontsize") ? 
		parameters["fontsize"] : 18;
	
	var borderThickness = parameters.hasOwnProperty("borderThickness") ? 
		parameters["borderThickness"] : 4;
	
	var borderColor = parameters.hasOwnProperty("borderColor") ?
		parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
	
	var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
		parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };

	var radius = parameters.hasOwnProperty("radius") ?
				parameters["radius"] : 6;

	var vAlign = parameters.hasOwnProperty("vAlign") ?
						parameters["vAlign"] : "center";

	var hAlign = parameters.hasOwnProperty("hAlign") ?
						parameters["hAlign"] : "center";

	var canvas = document.createElement('canvas');
	var context = canvas.getContext('2d');
	
	context.font = fontsize + "px " + fontface;
	context.textBaseline = "alphabetic";
	context.textAlign = "left";
    
	// get size data (height depends only on font size)
	var metrics = context.measureText( message );
	var textWidth = metrics.width;
	
	if ( textWidth > canvas.width ) {
		canvas.width = textWidth * 2;
		canvas.height = textWidth;
		// need to re-fetch and refresh the context after resizing
		context = canvas.getContext('2d');
		context.font = fontsize + "px " + fontface;
		context.textBaseline = "alphabetic";
		context.textAlign = "left";
	 	metrics = context.measureText( message );
		textWidth = metrics.width;
	}

	var cx = canvas.width / 2;
	var cy = canvas.height / 2;
	var tx = textWidth/ 2.0;
	var ty = fontsize / 2.0;

	if ( vAlign == "bottom")
		ty = 0;
	else if (vAlign == "top")
		ty = fontsize;
	
	if (hAlign == "left")
		tx = textWidth;
	else if (hAlign == "right")
		tx = 0;
	
	// background color
	context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
								  + backgroundColor.b + "," + backgroundColor.a + ")";
	// border color
	context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
								  + borderColor.b + "," + borderColor.a + ")";

	//context.lineWidth = borderThickness;
	roundRect(context, cx - tx , cy + ty + 0.28 * fontsize, textWidth, fontsize * DESCENDER_ADJUST, radius, borderThickness);
	// 1.4 is extra height factor for text below baseline: g,j,p,q.
	
	// text color
	context.fillStyle = 'blue'; //"rgba(1, 0, 0, 1.0)";

	//context.fillText( message, borderThickness, fontsize + borderThickness);
	context.fillText( message, cx - tx, cy + ty);

    context.strokeStyle = "rgba(0,255,0,1)";
    context.lineWidth = 2;
    context.beginPath(); 
    context.moveTo(cx-150,cy);
    context.lineTo(cx+150,cy);
    context.stroke();

    context.strokeStyle = "rgba(0,255,0,1)";
    context.lineWidth = 2;
    context.beginPath(); 
    context.moveTo(cx,cy-150);
    context.lineTo(cx,cy+150);
    context.stroke();

    /*
    context.strokeStyle = "rgba(255,0,0,1)";
    context.lineWidth = 2;
    context.beginPath(); 
    context.moveTo(0,0);
    context.lineTo(canvas.width, canvas.height);
    context.stroke();

    context.strokeStyle = "rgba(255,0,0,1)";
    context.lineWidth = 2;
    context.beginPath(); 
    context.moveTo(0,canvas.height);
    context.lineTo(canvas.width, 0);
    context.stroke();
	*/
    // canvas contents will be used for a texture
	var texture = new THREE.Texture(canvas) 
	texture.needsUpdate = true;

	var spriteMaterial = new THREE.SpriteMaterial( { map: texture } );
	var sprite = new THREE.Sprite( spriteMaterial );
	sprite.scale.set(1.5,0.75,1.0);
	return sprite;	
}

// function for drawing rounded rectangles
function roundRect(ctx, x, y, w, h, r, thick) 
{
	x -= thick + r;
	y += thick + r;
	w += thick * 2 + r * 2;
	h += thick * 2 + r * 2;
	
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y-r);
    ctx.lineTo(x+w, y-h-r);
    ctx.quadraticCurveTo(x+w, y-h, x+w-r, y-h);
    ctx.lineTo(x+r, y-h);
    ctx.quadraticCurveTo(x, y-h, x, y-h+r);
    ctx.lineTo(x, y-r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath();
    
	ctx.lineWidth = thick;

    ctx.fill();
    if (thick > 0)
    	ctx.stroke();   
}

/**
 * Animate the scene and call rendering.
 */
function animateScene() {

	// Tell the browser to call this function when page is visible
	requestAnimationFrame(animateScene);
	
	// Map the 3D scene down to the 2D screen (render the frame)
	nScene.renderScene();
}

</script>

</body>
</html>
