<!DOCTYPE html>
<html>
	<head>
		<!-- -------------------------------------
  			Roughly based (or inspired by) NeHe Tutorial 34
  			Original:  http://nehe.gamedev.net/tutorial/beautiful_landscapes_by_means_of_height_mapping/16006/
  
  			@author: rkwright@geofx.com
		-------------------------------------- -->
		<title>NEHE Lesson 34</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

		<!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
		<link rel="stylesheet" type="text/css" href="../css/NEHE.css" /> 

		<!-- Include several libraries from THREE.js and the Scene class  -->
		<script src="../js/three.js" type="text/javascript"></script>
		<script src="../js/Detector.js" type="text/javascript"></script>
		<script src="../js/OrbitControls-Touch.js" type="text/javascript"></script>
		<script src="../js/Stats.js" type="text/javascript"></script>
        <script src="../js/gfx-scene.js" type="text/javascript"></script>

        <!-- ---------------- Custom Shader Code ------------------------ -->
        <script id="vertexShader" type="x-shader/x-vertex">
            uniform sampler2D zTexture;
            uniform float zScale;

            varying float vAmount;

            void main()
            {
	            vec4 heightData = texture2D( zTexture, uv );

	            vAmount = heightData.r; // assuming map is grayscale it doesn't matter if you use r, g, or b.

	            // move the position along the normal
                vec3 newPosition = position + normal * zScale * vAmount;

	            gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
            }
        </script>

        <script id="fragmentShader" type="x-shader/x-vertex">

            varying float vAmount;

            void main()
            {
	            vec3 vColor = vec3(vAmount, vAmount, vAmount);
	            gl_FragColor = vec4(vColor, 1.0);
            }
        </script>
	</head>
	<body>

    <div style="position: absolute; top: 10px; left: 10px;color:white">
        <p></p>
    </div>



    <script type="text/javascript">

        // allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
        var gfxScene = new GFX.Scene( {
            cameraPos : [8, 10, 30],
            axesHeight: 30,
            controls:true,
            displayStats:true
        });

        // then initialize our demo's stuff
        initializeDemo();

        // Animate the scene
        animateScene();

        /**
         * Initialize the Demo.
         */
        function initializeDemo() {

            var SurfaceCover = [
                { name : "water", hue: 0.667, saturation: 1.0, brightness: 1 },
                { name : "grass", hue: 0.167, saturation: 0.5, brightness: 1 },
                { name : "chapparal", hue: 0.2, saturation: 0.67, brightness: 1 },
                { name : "hardwood", hue: 0.27, saturation: 0.75, brightness: 1 },
                { name : "conifer", hue: 0.39, saturation: 0.46, brightness: 1 },
                { name : "tundra", hue: 0.44, saturation: 0.33, brightness: 1 },
                { name : "rock", hue: 0.5, saturation: 0.1, brightness: 1 },
                { name : "snow", hue: 0.5, saturation: 0.0, brightness: 1 }
            ];

            var color = new THREE.Color();
            for (var i=0; i<SurfaceCover.length; i++ ) {
                color.setHSL(SurfaceCover[i].hue, SurfaceCover[i].saturation, SurfaceCover[i].brightness);
                console.log(SurfaceCover[i].name + " hsb: " + SurfaceCover[i].hue + ", " + SurfaceCover[i].saturation + ", " + SurfaceCover[i].brightness
                    + " rgb: " + color.r + ", " + color.g + ", " + color.b);
            }

            for ( var j=0; j<SurfaceCover.length; j++ ) {
                setHSV(color, SurfaceCover[j].hue, SurfaceCover[j].saturation, SurfaceCover[j].brightness);
                console.log(SurfaceCover[j].name + " hsb: " + SurfaceCover[j].hue + ", " + SurfaceCover[j].saturation + ", " + SurfaceCover[j].brightness
                    + " rgb: " + color.r + ", " + color.g + ", " + color.b);
            }

            for ( var n=0; n<SurfaceCover.length; n++ ) {
                color = HSVtoRGB( SurfaceCover[n].hue, SurfaceCover[n].saturation, SurfaceCover[n].brightness);
                console.log(SurfaceCover[n].name + " hsb: " + SurfaceCover[n].hue + ", " + SurfaceCover[n].saturation + ", " + SurfaceCover[n].brightness
                    + " rgb: " + color.r + ", " + color.g + ", " + color.b);

                var cubeGeometry = new THREE.BoxGeometry(2.0, 2.0, 2.0);
                var cubeMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    side: THREE.DoubleSide
                });

                cubeMesh = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cubeMesh.position.set( 2 * n - 5, 0, 0 );
                gfxScene.add(cubeMesh);
            }


            var loader = new THREE.TextureLoader();
			var zScale = 10;

            loader.load('images/terrain.png', function ( texture ) {
                // use "this." to create global object
                this.customUniforms = {
                    zTexture:	{ type: "t", value: texture },
                    zScale:	    { type: "f", value: zScale },
                };

                var customMaterial = new THREE.ShaderMaterial(
                    {
                        uniforms: customUniforms,
                        vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
                        fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
                        side: THREE.DoubleSide
                    });

                var planeGeo = new THREE.PlaneGeometry( 20, 20, 1023, 1023 );
                var plane = new THREE.Mesh(	planeGeo, customMaterial );
                plane.rotation.x = -Math.PI / 2;
                plane.position.y = -2;

                gfxScene.add(plane);
            });
        }

        function setHSV ( color, h, s, v ) {

            // https://gist.github.com/xpansive/1337890#file-index-js

            h = THREE.Math.euclideanModulo( h, 1 );
            s = THREE.Math.clamp( s, 0, 1 );
            v = THREE.Math.clamp( v, 0, 1 );

            var sat0 = ( s * v ) / ( ( h = ( 2 - s ) * v )) ;
            var denom =  ( ( h = ( 2 - s ) * v ) < 1 ? h : ( 2 - h ) );
            var sat = ( s * v ) / ( ( h = ( 2 - s ) * v ) < 1 ? h : ( 2 - h ) );

            return color.setHSL( h, ( s * v ) / ( ( h = ( 2 - s ) * v ) < 1 ? h : ( 2 - h ) ), h * 0.5 );
        }

        /******************************************************************************

         Converts from the HSV color model to the RGB color model.
         All input values [0, 1]., while the function returniing doubleing
         point values for each of the Red, Green, and Blue components.

         Reference:  Fundamentals of interactive computer graphics,
         J.D. Foley, A. Van Dam, p.614-616.

         -----------------------------------------------------------------------------*/
        function HSVtoRGB ( hue, sat, value ) {
            var hInt;    /* integer part of 6*hue */
            var p, q, t;
            var hFrac;   /* fractional part of 6*hue */

            var color = new THREE.Color();

            /* no saturation, so just return shade of grey */
            if (sat === 0.0) {
                color.setRGB(value, value, value);
                return color;
            }

            hInt = Math.floor(6.0 * hue);
            hFrac = 6.0 * hue - hInt;
            p = value * (1.0 - sat);
            q = value * (1.0 - sat * hFrac);
            t = value * (1.0 - sat * (1.0 - hFrac));

            switch (hInt) {
                case 6:
                case 0:
                    color.setRGB(value, t, p);
                    break;
                case 1:
                    color.setRGB(q, value, p);
                    break;
                case 2:
                    color.setRGB(p, value, t);
                    break;
                case 3:
                    color.setRGB(p, q, value);
                    break;
                case 4:
                    color.setRGB(t, p, value);
                    break;
                case 5:
                    color.setRGB(value, p, q);
            }

            return color;
        }

        /**
         * Animate the scene and call rendering.
         */
        function animateScene() {

            // Tell the browser to call this function when page is visible
            requestAnimationFrame(animateScene);

            // Map the 3D scene down to the 2D screen (render the frame)
            gfxScene.renderScene();
        }

    </script>

	</body>
</html>
