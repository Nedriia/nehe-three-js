<!DOCTYPE html>
<html lang="en">
<head>
    <!-- -------------------------------------
        Very roughly based (or inspired by) NeHe Tutorial 36
	Original:  http://nehe.gamedev.net/tutorial/playing_avi_files_in_opengl/23001/
    Largely cloned from https://medium.com/@andrew_b_berg/volumetric-light-scattering-in-three-js-6e1850680a41

    @author: rkwright@geofx.com
	-------------------------------------- -->
	<title>NEHE Lesson 39</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

    <!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
	<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="../css/NEHE.css" />

    <!-- Include several libraries from THREE.js and the Scene class  -->
	<script src="../js/three.js" type="text/javascript"></script>
    <script src="../js/Detector.js" type="text/javascript"></script>
    <script src="../js/OrbitControls-Touch-Ortho.js" type="text/javascript"></script>
    <script src="../js/stats.js" type="text/javascript"></script>
    <script src="../js/gfx-scene.js" type="text/javascript"></script>
    <script src="js/State3D.js" type="text/javascript"></script>
    <script src="js/Derivative.js" type="text/javascript"></script>
    <script src="js/Physics3D.js" type="text/javascript"></script>

</head>
<body>

	<div style="position: absolute; top: 10px; left: 10px;color:white">
		<p></p>
	</div>

	<script type="text/javascript">

        var physics3D;
        var cubeMesh;
        var plateMesh;
        var springMesh;
        var DAMPING_TORQUE = -0.5;
        var FORCE_X = 0;
        var FORCE_Y = 2;
        var FORCE_Z = 0;
        var FORCE_SCALE = -5.0;
        var TORQUE_X = 0.0;
        var TORQUE_Y = 1.0;
        var TORQUE_Z = 0.0;

        // allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
        var gfxScene = new GFX.Scene( {
            cameraPos : [8, 6, 15],
            axesHeight:10,
            controls:true,
            displayStats:"fps ms"
        });

        // then initialize our demo's stuff
        initializeDemo();

        // Animate the scene
        animateScene();

        /**
         * Initialize the Demo.
         */
        function initializeDemo() {

            createHelix();

            //drawSplineCurve();

            //createSineCurve();

            var initialPos = new THREE.Vector3(0, 5, 0);
            var initialMom = new THREE.Vector3(0, 0, 0);
            var mass = 1.0;
            var size = 1.0;

            physics3D = new GFX.Physics3D( render, forces, initialPos, initialMom, mass, size );

            var cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
            cubeMesh = new THREE.Mesh(cubeGeometry, new THREE.MeshLambertMaterial({color:0xFF0000}));
            cubeMesh.position.set(0,10,0);
            gfxScene.add(cubeMesh);

            var plateGeometry = new THREE.BoxGeometry(3, 0.25, 3);
            plateMesh = new THREE.Mesh(plateGeometry, new THREE.MeshLambertMaterial({color:0x888888}));
            plateMesh.position.set(0,5.125,0);
            gfxScene.add(plateMesh);
        }

        function drawSpline() {
            var numPoints = 10;
            //        var start = new THREE.Vector3(-5, 0, 20);
            var start = new THREE.Vector3(-5, 0, 20);
            var middle = new THREE.Vector3(0, 35, 0);
            var end = new THREE.Vector3(5, 0, -20);

            var curveQuad = new THREE.QuadraticBezierCurve3(start, middle, end);

            var tube = new THREE.TubeGeometry(curveQuad, numPoints, 0.5, 20, false);
            var mesh = new THREE.Mesh(tube, new THREE.MeshNormalMaterial({
                opacity: 0.9,
                transparent: true
            }));

            scene.add(mesh);
            renderer.render(scene, camera);
        }

        function render( state ) {

            //console.log("x,y,z: " + state.position.x.toFixed(2) + " " + state.position.y.toFixed(2) + " " +
            //       state.position.z.toFixed(2));

            cubeMesh.position.set(state.position.x, state.position.y, state.position.z);
            cubeMesh.rotation.y = 2.0 *  Math.acos(state.orientation.w);

            createSpring( state.position.y );
        }

        function createSpring( posY ) {
            var h = 6 - posY;
            var cylY = 5.5 - h * 0.5;

            gfxScene.remove( springMesh );

            var springGeometry = new THREE.CylinderGeometry(0.1, 0.1, h, 32);
            springMesh = new THREE.Mesh(springGeometry, new THREE.MeshLambertMaterial({color:0x888888}));
            springMesh.position.set(0,cylY,0);
            gfxScene.add(springMesh);
        }

        function createSineCurve() {
            var path = new CustomSinCurve(10);
            var geometry = new THREE.TubeGeometry(path, 20, 2, 8, false);
            var material = new THREE.MeshBasicMaterial({color: 0x00ff00});
            var mesh = new THREE.Mesh(geometry, material);
            gfxScene.add(mesh);
        }

        function drawSplineCurve () {
            var vec = [];
            vec.push( new THREE.Vector3(-1, 0, 1 ) );
            vec.push( new THREE.Vector3(-0.5, 0.5, 0.5) );
            vec.push( new THREE.Vector3(0, 0, 0) );
            vec.push( new THREE.Vector3(0.5, -0.5, 0.5) );
            vec.push( new THREE.Vector3(1, 0, 1) );

            var curve = new THREE.SplineCurve3( vec );

            var geometry = new THREE.TubeGeometry(
                curve,  //path
                20,    //segments
                0.2,     //radius
                8,     //radiusSegments
                false  //closed
            );

            var material = new THREE.MeshLambertMaterial({color: 0x00ff00});
            var mesh = new THREE.Mesh(geometry, material);
            gfxScene.add(mesh);
        }

        function createHelix() {
            var x,y = -5,z;
            var radius = 0.25;
            var n = 0;
            var NTWISTS = 10;
            var ANGLE_INCR = Math.PI / 12;
            var TWO_PI = Math.PI * 2.0;
            var HEIGHT = 10;
            var ZINCR = HEIGHT / (TWO_PI / ANGLE_INCR * NTWISTS );
            var helix = [];

            for( var phi=0; phi<=TWO_PI*NTWISTS; phi+=ANGLE_INCR )
            {
                x = Math.cos(phi) * radius;
                y += ZINCR;
                z = Math.sin(phi) * radius;

                helix.push( new THREE.Vector3(x, y, z));

                console.log( "n: " +  n++ + " phi: " + phi.toFixed(2) + " x: " + x.toFixed(2)+ " y: " + y.toFixed(2)+ " z: " + z.toFixed(2));
            }

            var curve = new THREE.CatmullRomCurve3( helix );

            var geometry = new THREE.TubeGeometry(
                curve,  //path
                n,    //segments
                0.1,     //radius
                8,     //radiusSegments
                false  //closed
            );

            var material = new THREE.MeshLambertMaterial({color: 0xc0c0c0});
            var mesh = new THREE.Mesh(geometry, material);
            gfxScene.add(mesh);

            mesh.scale.set(1, 0.25, 1);
        }
        
        // Calculate force and torque for physics state at time t.
        // Due to the way that the RK4 integrator works we need to calculate
        // force implicitly from state rather than explicitly applying forces
        // to the rigid body once per update. This is because the RK4 achieves
        // its accuracy by detecting curvature in derivative values over the
        // timestep so we need our force values to supply the curvature.
        function forces (state, t, derivative ) {

            // attract towards origin
            derivative.force.copy(state.position);
            derivative.force.multiplyScalar(FORCE_SCALE);

            // add forces to the calculated derivative
            derivative.force.x += FORCE_X;
            derivative.force.y += FORCE_Y;
            derivative.force.z += FORCE_Z;

            // add torque to the calculated derivative
            derivative.torque.x = TORQUE_X;
            derivative.torque.y = TORQUE_Y;
            derivative.torque.z = TORQUE_Z;

            // damping torque so we don't spin too fast
            derivative.torque.addScaledVector( state.angularVelocity, DAMPING_TORQUE );
        }

        /**
         * Animate the scene and call rendering.
         */
        function animateScene() {

            // Tell the browser to call this function when page is visible
            requestAnimationFrame(animateScene);

            physics3D.timeStep();

            // Map the 3D scene down to the 2D screen (render the frame)
            gfxScene.renderScene();
        }
    </script>
</body>
</html>
